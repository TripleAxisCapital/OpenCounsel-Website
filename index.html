<!-- Sync Successful -->

<!DOCTYPE html>
<html lang="en" class="scroll-smooth">
<head>

  <!-- ───── OpenCounsel.ca (www): SEO + Favicon using logo1.svg ───── -->
<title>The AI Workspace. Without Limits.</title>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
<meta name="description" content="The AI Workspace. Without Limits. Private, polished, and powerful.">
<link rel="canonical" href="https://www.opencounsel.ca/">
<meta name="robots" content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1">
<link rel="sitemap" type="application/xml" href="https://www.opencounsel.ca/sitemap.xml">
<link rel="icon" type="image/png" href="OClogo.png">
<!-- Internationalization -->
<link rel="alternate" href="https://www.opencounsel.ca/" hreflang="x-default">
<link rel="alternate" href="https://www.opencounsel.ca/en/" hreflang="en">

<!-- Performance & UX -->
<link rel="preconnect" href="https://cdn.opencounsel.ca" crossorigin>
<link rel="dns-prefetch" href="//cdn.opencounsel.ca">
<link rel="preload" as="font" href="/fonts/InterVariable.woff2" type="font/woff2" crossorigin>
<link rel="preload" as="image" href="/images/og/opencounsel-hero.jpg" fetchpriority="high">
<!-- Preload local mask logo to ensure instant swap -->
<link rel="preload" as="image" href="/logo.svg">
<meta http-equiv="x-dns-prefetch-control" content="on">
<meta name="theme-color" content="#0B1B2B">

<!-- Icons (use logo1.svg for favicon) -->
 <link rel="icon" href="/logo.svg?v=1" type="image/svg+xml" sizes="any">


<!-- Open Graph / Facebook -->
<meta property="og:type" content="website">
<meta property="og:site_name" content="ONX">
<meta property="og:title" content="The AI Workspace. Without Limits.">
<meta property="og:description" content="The AI Workspace. Without Limits.">
<meta property="og:url" content="https://www.opencounsel.ca/">
<meta property="og:image" content="https://www.opencounsel.ca/images/og/opencounsel-1200x630.jpg">
<meta property="og:image:width" content="1200">
<meta property="og:image:height" content="630">

<!-- Twitter / X -->
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="@OpenCounselAI">
<meta name="twitter:title" content="ONX — The AI Workspace. Without Limits.">
<meta name="twitter:description" content="The AI Workspace. Without Limits.">
<meta name="twitter:image" content="https://www.opencounsel.ca/images/og/opencounsel-1200x630.jpg">

<!-- Structured Data (Organization/WebSite) — point logo to logo1.svg -->
<script type="application/ld+json">
{
  "@context":"https://schema.org",
  "@graph":[
    {
      "@type":"Organization",
      "name":"ONX",
      "url":"https://www.opencounsel.ca/",
      "logo":"https://www.opencounsel.ca/icons/logo1.svg",
      "sameAs":[
        "https://x.com/OpenCounselAI",
        "https://www.linkedin.com/company/opencounsel",
        "https://github.com/opencounsel"
      ]
    },
    {
      "@type":"WebSite",
      "url":"https://www.opencounsel.ca/",
      "name":"ONX",
      "potentialAction":{
        "@type":"SearchAction",
        "target":"https://www.opencounsel.ca/search?q={query}",
        "query-input":"required name=query"
      }
    }
  ]
}
</script>
<!-- ─────────────────────────────────────────────────────────────── -->

<!-- Pretty URL (client-side mask) -->
<script>
  window.ONX = { base:"", slug:"Home", file:"/index.html" }; // ← change per page

  (function(L,C){try{
    var B=C.base||"", S="/"+(C.slug||"home"), F=C.file||"/index.html";
    var p=L.pathname.replace(/\/+$/,"");
    if(B && p.startsWith(B)) p=p.slice(B.length)||"/";
    if(p===F || p==="/") history.replaceState(null,"",B+S+L.search+L.hash);
  }catch(_){}})(location, window.ONX);
</script>

  <!-- iOS/Standalone (lets users hide Safari UI when launched from Home Screen) -->
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="ONX">
  <!-- Optional icons/manifest (add these files to fully enable the standalone PWA look) -->
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  <link rel="manifest" href="/manifest.webmanifest">
  <meta name="theme-color" content="#0B1B2B">

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap" rel="stylesheet">
  <!-- Icons + Tailwind -->
  <script src="https://unpkg.com/@phosphor-icons/web"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    tailwind.config = {
      theme: {
        extend: {
          fontFamily: { sans: ['Inter','ui-sans-serif','system-ui'] },
          colors: {
            oc: { ink:'#0A0D10', soft:'#F5F7F9', line:'#E7EDF2', accent:'#5B8CFF', lilac:'#E7E7FF' }
          },
          boxShadow: {
            card:'0 6px 30px rgba(16,24,40,0.08)',
            glow:'0 0 0 1px rgba(255,255,255,.06), 0 10px 30px rgba(16,24,40,.18)'
          }
        }
      }
    }
  </script>

  <style>
    /* ================================
       GLOBAL CONTROLS
       ================================ */
    :root {
      --pad-mobile-x: 24px;
      --pad-desktop-x: 32px;
      --hamburger-inset: 13px;
      /* Global header roundness */
      --header-radius: 28px;
      /* Header inner padding (per side, per breakpoint) */
      --header-pad-left-mobile: calc(var(--pad-mobile-x) + 12px);
      --header-pad-right-mobile: calc(var(--pad-mobile-x) + 12px);
      --header-pad-left-desktop: calc(var(--pad-desktop-x) + 16px);
      --header-pad-right-desktop: calc(var(--pad-desktop-x) + 16px);

      /* ==== Global Scroll-Blur Controls (content inside cards) ==== */
      --scroll-blur-start: 16px;
      --scroll-blur-end: 0px;
      --scroll-blur-duration: 1100ms; /* smoother */
      --scroll-blur-ease: cubic-bezier(.16,1,.3,1); /* Apple-y ease-out */
      --scroll-blur-opacity-start: .65;
      --scroll-blur-opacity-end: 1;
      --scroll-blur-translate: 8px;

      /* ==== Card backdrop blur controls (the glass card itself) ==== */
      --card-blur-start: 12px;
      --card-blur-end: 0px;
      --card-blur-duration: 900ms;
      --card-blur-ease: cubic-bezier(.16,1,.3,1);
    }

    /* Kill horizontal scroll without breaking sticky */
    html, body { max-width: 100%; overflow-x: clip !important; }
    @supports not (overflow-x: clip) { html, body { overflow-x: hidden !important; } }
    .section-clip { position: relative; overflow-x: clip; }

    .oc-container { padding-left: var(--pad-mobile-x); padding-right: var(--pad-mobile-x); }
    @media (min-width: 1024px) { .oc-container { padding-left: var(--pad-desktop-x); padding-right: var(--pad-desktop-x); } }
    ::selection{background:#5B8CFF;color:#fff}

    @media (prefers-reduced-motion: no-preference) {
      .reveal { opacity:0; transform: translateY(18px) scale(.98); transition: opacity .6s ease, transform .6s ease; }
      .reveal.in { opacity:1; transform: translateY(0) scale(1); }
      .tilt:hover{ transform: translateY(-2px) scale(1.01); }
      .tilt{ transition: transform .25s ease; }
    }

    @keyframes logoIntro { from { transform: translateY(6px) scale(.92); opacity:0 } to { transform: translateY(0) scale(1); opacity:1 } }
    @keyframes gradientShift { 0%{background-position:0% 50%} 50%{background-position:100% 50%} 100%{background-position:0% 50%} }

    /* ========= PRIMITIVES ========= */
    .g-grad, .grad-anim{
      background: linear-gradient(var(--angle, 135deg), var(--from, #0a1f44cc), var(--via, #0b3d3dcc), var(--to, #064420cc));
      background-size: 300% 300%; animation: gradientShift var(--speed, 16s) ease-in-out infinite; will-change: background-position;
    }
    .animated-gradient { background-size:300% 300%; animation:gradientShift 16s ease-in-out infinite; will-change:background-position; }

    @keyframes heroLogoReveal {
      0%   { opacity: 0; filter: blur(8px); transform: translateY(6px) scale(.985); }
      60%  { opacity: 1; filter: blur(1.5px); transform: translateY(0) scale(1.000); }
      100% { opacity: 1; filter: blur(0); transform: translateY(0) scale(1); }
    }


    .grad-text{
      background: linear-gradient(var(--angle,135deg), var(--from,#0a1f44cc), var(--via,#0b3d3dcc), var(--to,#064420cc));
      background-size: 300% 300%; animation: gradientShift var(--speed,16s) ease-in-out infinite;
      -webkit-background-clip: text; background-clip: text; -webkit-text-fill-color: transparent; color: transparent;
    }

  </style>

<style>
  :root { --pad-top: 112px; }
  .padTop { padding-top: var(--pad-top); }
</style>
<link href="https://fonts.googleapis.com/css2?family=Audiowide&display=swap" rel="stylesheet">

</head>





<!--========================== BODY ========================== -->

<body class="bg-white text-oc-ink font-sans antialiased">

  <!-- Load the header component -->
  <script type="module" src="/assets/onx-header.js"></script>

  <!-- Place the header here -->
  <onx-header
    width-flat="75%"
    max-w="1200px"
    pad-flat-top="0rem"
    pad-flat-bottom="0rem"
    pad-float-top-mobile=".75rem"
    pad-float-bottom-mobile=".25rem"
    pad-float-top-desktop="1rem"
    pad-float-bottom-desktop=".25rem"
    threshold="8">

    <!-- Extra center nav links -->

    <!-- Extra right-side action -->
  </onx-header>

<!--=======================================================================START===============================================================================================-->
<!--======================================================================CHAT SECTION================================================================================================-->
<!-- ===== Full-screen Chat Hero (Apple-minimal) — centered bubble + background word stream ===== -->
<section id="chat-hero" aria-label="Chat hero">
  <style>
    /* ---------------- Design tokens ---------------- */
    #chat-hero{
      --bg:#ffffff;
      --ink:#0B0B0C;
      --muted:#77808d;
      --line:#E6E8EC;

      --radius:28px;                 /* bubble radius */
      --bubbleH:78px;                /* initial min bubble height (auto-updates via JS) */
      --maxW:940px;                  /* max bubble width */
      --screenPadX:20px;             /* bubble -> viewport side padding */
      --titleGap:28px;               /* space between title and bubble */

      /* Animation timings */
      --fade:360ms;                  /* fade-out duration for sentence swap */

      /* === Edit me (mobile & desktop controls) === */
      /* Mobile (default) */
      --padX-m:16px;
      --padY-m:14px;
      --sendScale-m:.50;

      /* Desktop (>=768px) */
      --padX-d:20px;
      --padY-d:18px;
      --sendScale-d:.75;

      /* Base + active mappings */
      --padX:var(--padX-m);
      --padY:var(--padY-m);
      --sendBase:56px;
      --sendScale:var(--sendScale-m);
      --sendSize:calc(var(--sendBase) * var(--sendScale));
      --sendIconRatio:.3928571429;   /* 22/56 */

      --shadowA:0 1px 0 rgba(0,0,0,.04);
      --shadowB:0 18px 40px rgba(0,0,0,.06);

      /* Word stream colors */
      --c1:#3f6768;
      --c2:#57c7d9;

      /* Track length for floating words */
      --trail: 20vh;

      /* Travel distance upward */
      --rise: calc(125vh + (var(--trail) * 0.5));

      /* START OFF-SCREEN to avoid pop-ins */
      --startTop: 110%;

      /* Title legibility shield (no visible plate; adaptive glow) */
      --titleStroke: .35px;          /* micro stroke width */
      --titleGlow1: .70;             /* inner halo strength */
      --titleGlow2: .55;             /* mid halo */
      --titleGlow3: .35;             /* outer halo */

      /* Section edge fades (Apple-style blend) */
      --fadeH-bottom: 14vh;          /* bottom reveal fade height */
      --fadeH-top: 10vh;             /* top dissolve fade height */
    }

    @media (min-width:768px){
      #chat-hero{
        --padX:var(--padX-d);
        --padY:var(--padY-d);
        --sendScale:var(--sendScale-d);
        --sendSize:calc(var(--sendBase) * var(--sendScale));
        --fadeH-bottom: 16vh;
        --fadeH-top: 12vh;
      }
    }

    /* --------------- Section layout --------------- */
    #chat-hero{
      position:relative;
      min-height: calc(100vh + var(--trail));
      min-height: calc(100svh + var(--trail));
      background:var(--bg);
      box-sizing:border-box;
      isolation:isolate;
      -webkit-tap-highlight-color: transparent;
      font-family: ui-sans-serif, -apple-system, BlinkMacSystemFont, "SF Pro Text",
                   "Segoe UI", Roboto, "Helvetica Neue", Arial, "Apple Color Emoji",
                   "Segoe UI Emoji";
      -webkit-font-smoothing:antialiased;
      text-rendering:optimizeLegibility;
      color:var(--ink);
      overflow:hidden;
    }

    /* ---- Apple-style edge fades (above words, below UI) ---- */
    #chat-hero::before,
    #chat-hero::after{
      content:"";
      position:absolute;
      left:0; right:0;
      pointer-events:none;
      z-index:1; /* between word-stream (0) and UI (2) */
    }
    /* top dissolve */
    #chat-hero::before{
      top:0; height:var(--fadeH-top);
      background:linear-gradient(to bottom, var(--bg) 0%, rgba(255,255,255,0) 100%);
      /* Dark-mode friendly: var(--bg) adapts below */
    }
    /* bottom reveal */
    #chat-hero::after{
      bottom:0; height:var(--fadeH-bottom);
      background:linear-gradient(to top, var(--bg) 0%, rgba(255,255,255,0) 100%);
    }

    /* ---------------- Background word stream ---------------- */
    #chat-hero .word-stream{
      position:absolute;
      inset:0;
      z-index:0;                 /* stays behind everything */
      pointer-events:none;
      overflow:hidden;
    }

    /* rising word container */
    #chat-hero .ws-word{
      position:absolute;
      left:50%;
      top:var(--startTop);
      transform:translate3d(-50%,0,0) scale(var(--scale,1));
      margin-left:var(--x,0%);
      opacity:0;
      will-change:transform,opacity;
      animation:ws-rise var(--dur,10s) cubic-bezier(.22,.61,.36,1) var(--delay,0s) forwards;
    }
    @keyframes ws-rise{
      0%   { opacity:0; transform:translate3d(calc(-50% + var(--x,0%)), 0, 0) scale(var(--scale,1)); }
      10%  { opacity:1; }
      100% { opacity:1; transform:translate3d(calc(-50% + var(--x,0%)), calc(var(--rise) * -1), 0) scale(var(--scale,1)); }
    }

    /* lateral sway wrapper */
    #chat-hero .ws-sway{
      display:inline-block;
      will-change:transform;
      animation:ws-sway var(--swaydur,8s) ease-in-out var(--delay,0s) infinite alternate;
    }
    @keyframes ws-sway{
      from { transform:translateX(0); }
      to   { transform:translateX(var(--sway,3%)); }
    }

    /* gradient/shimmering text */
    #chat-hero .ws-text{
      display:block;
      font-family: Inter, -apple-system, system-ui, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
      font-size:clamp(28px,8vw,72px);
      font-weight:500;
      letter-spacing:0.26em;
      line-height:1.15;
      text-transform:uppercase;
      white-space:nowrap;

      background:linear-gradient(120deg, var(--c1) 20%, var(--c2) 50%, var(--c1) 80%);
      background-size:220% 100%;
      -webkit-background-clip:text;
      background-clip:text;
      color:transparent;

      animation:
        ws-shimmer 8s ease-in-out infinite,
        ws-float   3.8s ease-in-out infinite alternate,
        ws-breathe 7s  ease-in-out infinite;
      will-change:background-position, filter, transform;
      text-shadow:none;
    }
    @keyframes ws-shimmer{ 0%{background-position:0% 50%} 100%{background-position:200% 50%} }
    @keyframes ws-float  { from{transform:translateY(0)} to{transform:translateY(-2px)} }
    @keyframes ws-breathe{
      0%,100% { filter:brightness(1) saturate(1); text-shadow:none; }
      50%     { filter:brightness(1.06) saturate(1.03); text-shadow:0 0 12px rgba(87,199,217,.12); }
    }

    /* ------------------ Foreground UI (above stream) --------------------- */
    #chat-hero .hero-title{ z-index:2; }
    #chat-hero .bubble-spot{ z-index:2; }

    /* ------------------ Title --------------------- */
    #chat-hero .hero-title{
      position:absolute;
      left:50%;
      top: calc(50vh - (var(--bubbleH) / 2) - var(--titleGap));
      transform: translate(-50%, -100%);
      margin:0;
      text-align:center;
      letter-spacing:-0.02em;
      line-height:1.1;
      font-weight:700;
      font-size:clamp(28px, 5.2vw, 54px);
      padding:0 12px;
    }

    /* Adaptive legibility shield (no plate; glow + micro stroke) */
    #chat-hero .hero-title .title-blur{
      /* This element wraps the entire line, so shadows apply to both ONX and the rest */
      text-shadow:
        0 0 0 rgba(0,0,0,0),                                    /* placeholder for transition matching */
        0 0 8px rgba(255,255,255, var(--titleGlow1)),
        0 0 18px rgba(255,255,255, var(--titleGlow2)),
        0 0 28px rgba(255,255,255, var(--titleGlow3));
      -webkit-text-stroke: var(--titleStroke) rgba(255,255,255,.55); /* micro outline, invisible on white */
    }

    /* --------------- Bubble spot (center) ---------- */
    #chat-hero .bubble-spot{
      position:absolute;
      left:50%;
      top:50vh;
      transform:translate(-50%, -50%);
      width:min(calc(100vw - (var(--screenPadX)*2)), var(--maxW));
      height:auto;
    }

    /* --------------- Chat bubble shell ------------- */
    #chat-hero .bubble{
      position:relative;
      width:100%;
      min-height:var(--bubbleH);
      height:auto;
      display:flex;
      align-items:center;
      border:1px solid var(--line);
      border-radius:var(--radius);
      background:#fff;
      box-shadow:var(--shadowA), var(--shadowB);
      padding-left:var(--padX);
      padding-right:calc(var(--padX) + var(--sendSize) + 14px);
      padding-top:var(--padY);
      padding-bottom:var(--padY);
      transition:box-shadow .15s ease;
      box-sizing:border-box;
    }

    /* Keyboard-only focus ring */
    #chat-hero .bubble:has(.prompt:focus-visible){
      box-shadow:0 0 0 2px #DBE3FF inset, var(--shadowA), var(--shadowB);
    }

    /* ---------------- Multiline input ------------- */
    #chat-hero .prompt{
      flex:1 1 auto;
      display:block;
      width:100%;
      min-height:1.35em;
      font-size:clamp(16px, 2.2vw, 22px);
      line-height:1.35;
      color:#0b0b0c;
      border:0; background:transparent; outline:0;
      caret-color:#0b0b0c;
      resize:none; overflow:hidden;
      padding:0;
      white-space:pre-wrap;
      word-break:break-word;
      overflow-wrap:anywhere;
      -webkit-appearance:none; appearance:none;
      transition:opacity var(--fade) ease;
      opacity:1;
    }
    #chat-hero .prompt.is-fading{ opacity:0; }
    #chat-hero .prompt::placeholder{ color:var(--muted); opacity:.95; }

    /* ---------------- Scalable Send button ---------- */
    #chat-hero .send{
      position:absolute;
      right:10px; top:50%; transform:translateY(-50%);
      width:var(--sendSize); height:var(--sendSize);
      border-radius:999px; border:1px solid #0b0b0c;
      background:#0b0b0c; display:grid; place-items:center;
      cursor:pointer;
      transition:transform .15s ease, background-color .15s ease, box-shadow .15s ease, border-color .15s ease;
      box-shadow:0 2px 6px rgba(0,0,0,.10), 0 10px 24px rgba(0,0,0,.08);
      touch-action:manipulation;
      z-index:3;
    }
    #chat-hero .send:hover{ background:#121212; transform:translateY(calc(-50% - 1px)); }
    #chat-hero .send:active{ transform:translateY(-50%); }
    #chat-hero .send svg{
      width:calc(var(--sendSize) * var(--sendIconRatio));
      height:calc(var(--sendSize) * var(--sendIconRatio));
      display:block; fill:none; stroke:#fff;
      stroke-width:2; stroke-linecap:round; stroke-linejoin:round;
    }

    /* ------------------ Dark mode ------------------ */
    @media (prefers-color-scheme: dark){
      #chat-hero{ --bg:#0B0B0C; --ink:#F3F6FB; --muted:#B8BFCA; --line:#22262D; }
      #chat-hero .bubble{ background:#0F1217; }
      #chat-hero .prompt{ color:#F3F6FB; caret-color:#F3F6FB; }
      #chat-hero .bubble:has(.prompt:focus-visible){
        box-shadow:0 0 0 2px #2A3550 inset, var(--shadowA), var(--shadowB);
      }
      /* Fades adapt automatically via var(--bg) */
      /* Title shield stays invisible yet effective on dark */
      #chat-hero .hero-title .title-blur{
        -webkit-text-stroke: var(--titleStroke) rgba(0,0,0,.55);
        text-shadow:
          0 0 8px rgba(0,0,0,.55),
          0 0 18px rgba(0,0,0,.45),
          0 0 28px rgba(0,0,0,.35);
      }
    }

    /* ------------- Reduced motion ------------- */
    @media (prefers-reduced-motion: reduce){
      #chat-hero .send{ transition:none; }
      #chat-hero .prompt{ transition:none; }
      #chat-hero .ws-word, #chat-hero .ws-sway, #chat-hero .ws-text{
        animation:none !important; opacity:1 !important; transform:none !important;
      }
    }

    /* Audiowide, solid black (no breathing/shimmer) */
    #chat-hero .hero-title .title-onx{
      font-family:"Audiowide", ui-sans-serif, system-ui, -apple-system, "SF Pro Text", "Segoe UI", Roboto, "Helvetica Neue", Arial;
      font-weight:400;
      color:#0B0B0C;
      background:none;
      -webkit-background-clip:initial;
      background-clip:initial;
      animation:none;
    }
  </style>

  <!-- Background floating words (starts ONLY after user scrolls) -->
  <div
    class="word-stream"
    data-rate="900"
    data-dmin="9"
    data-dmax="14"
    data-band="12"
    data-lanes="5"
    data-gap="1000"
    data-max="28"
    aria-hidden="true">
    <script>
      (() => {
        const STREAM_WORDS = [
          "FOR ENTREPRENEURS","DESIGN","FOR INVESTORS",
          "FOR CREATORS","BUILD","FOR DEVELOPERS","CREATE",
          "FOR FOUNDERS","LAUNCH","FOR DESIGNERS","MARKETING",
          "SCALE","SHIP","INNOVATE","RESEARCH","OPTIMIZE","ANALYZE",
          "AUTOMATE","MONETIZE","SECURE","DEPLOY","PROTOTYPE","ITERATE",
          "COLLABORATE","LEARN","FOCUS","SIMPLIFY","POLISH","ELEVATE",
          "REDEFINE","CRAFT","DISCOVER","STRATEGIZE","ORCHESTRATE",
          "ACCELERATE","EXCEL","MASTER",
          "FOR TRADERS","FOR HEDGE FUNDS","FOR EXECUTIVES","FOR PRODUCT TEAMS",
          "FOR SALES","FOR MARKETERS","FOR ANALYSTS","FOR ENGINEERS",
          "FOR WRITERS","FOR INVENTORS","FOR SCIENTISTS","FOR STUDENTS",
          "FOR EDUCATORS","FOR RESEARCHERS","FOR OPERATORS","FOR STARTUPS",
          "FOR ENTERPRISE","FOR LAW FIRMS","FOR LAWYERS","FOR AGENCIES",
          "FOR TEAMS","FOR SOLOPRENEURS","FOR BUILDERS"
        ];

        const host = document.currentScript.parentElement;
        const RATE   = +(host.dataset.rate  || 900);
        const DMIN   = +(host.dataset.dmin  || 9);
        const DMAX   = +(host.dataset.dmax  || 14);
        const BAND   = +(host.dataset.band  || 12);
        const LANES  = Math.max(1, +(host.dataset.lanes || 5));
        const LANE_GAP = +(host.dataset.gap || 1000);
        const MAXN   = +(host.dataset.max   || 28);

        /* Immediate, smooth start on first scroll */
        const EARLY_COUNT = 6;
        const EARLY_GAP   = Math.max(220, RATE * 0.35);
        const EARLY_DUR_MULT = 0.72;
        const SEED_BURST  = 4;  /* kick several words in right away */

        const laneOffsets = Array.from({length: LANES}, (_, i) => {
          return (LANES === 1) ? 0 : ((i/(LANES-1))*2 - 1) * BAND;
        });
        const laneReadyAt = new Array(LANES).fill(0);

        const shuffle = a => { for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]] } return a; };
        let queue = shuffle([...STREAM_WORDS]);

        function pickLane(now){
          const free = [];
          for (let i=0;i<LANES;i++) if (now >= laneReadyAt[i]) free.push(i);
          return free.length ? free[Math.floor(Math.random()*free.length)] : -1;
        }

        function spawn(opts = { seed:false, early:false }){
          const now  = performance.now();
          const lane = pickLane(now);
          if (lane < 0) return;

          if (queue.length === 0) queue = shuffle([...STREAM_WORDS]);
          const phrase = queue.pop();

          let dur  = DMIN + Math.random()*(DMAX - DMIN);
          if (opts.early) dur *= EARLY_DUR_MULT;

          const scale  = 0.96 + Math.random()*0.14;
          const laneX  = laneOffsets[lane];

          const laneSpan = (LANES === 1) ? (BAND*2) : (2*BAND)/(LANES-1);
          const swayMax  = Math.max(0.6, (laneSpan*0.38));
          const sway     = (Math.random()<.5?-1:1) * (0.6 + Math.random()*(swayMax - 0.6));
          const swayDur  = 6 + Math.random()*6;

          const outer = document.createElement('span');
          outer.className = 'ws-word';
          outer.style.setProperty('--dur',   dur.toFixed(2)+'s');
          outer.style.setProperty('--x',     laneX.toFixed(2)+'%');
          outer.style.setProperty('--scale', scale.toFixed(2));

          /* No negative delays; immediate entrance from bottom on scroll */
          const delaySeconds = opts.seed
            ? 0
            : (opts.early ? Math.random()*0.15 : Math.random()*0.6);
          outer.style.setProperty('--delay', delaySeconds.toFixed(2) + 's');

          const sw = document.createElement('span');
          sw.className = 'ws-sway';
          sw.style.setProperty('--sway',    sway.toFixed(2)+'%');
          sw.style.setProperty('--swaydur', swayDur.toFixed(2)+'s');

          const t = document.createElement('span');
          t.className = 'ws-text';
          t.textContent = phrase;

          sw.appendChild(t);
          outer.appendChild(sw);
          host.appendChild(outer);

          const nodes = host.querySelectorAll('.ws-word');
          if (nodes.length > MAXN) nodes[0]?.remove();

          laneReadyAt[lane] = now + LANE_GAP;
          outer.addEventListener('animationend', () => outer.remove(), {once:true});
        }

        let started = false, earlyLeft = EARLY_COUNT, timerId = null;
        function scheduleNext(delay){
          timerId = setTimeout(() => {
            const useEarly = earlyLeft > 0;
            spawn({ seed:false, early:useEarly });
            if (useEarly) earlyLeft--;
            const nextGap = (earlyLeft > 0) ? EARLY_GAP : RATE;
            scheduleNext(nextGap);
          }, delay);
        }

        function start(){
          if (started) return;
          started = true;

          /* Seed a few words immediately from bottom */
          for (let i=0; i<SEED_BURST; i++) spawn({ seed:true, early:true });

          /* Then continue at a quick cadence before normalizing */
          scheduleNext(0);
        }

        window.addEventListener('wheel', start, {once:true, passive:true});
        window.addEventListener('scroll', start, {once:true, passive:true});
        window.addEventListener('touchmove', start, {once:true, passive:true});

        const obs = new MutationObserver(() => {
          if (!document.body.contains(host) && timerId){
            clearTimeout(timerId);
            obs.disconnect();
          }
        });
        obs.observe(document.body, {childList:true, subtree:true});
      })();
    </script>
  </div>

  <!-- Title (positioned relative to bubble center / viewport) -->
  <h1 class="hero-title">
    <span class="title-blur">
      <span class="title-onx">ONX</span> is Unstoppable
    </span>
  </h1>

  <!-- The centered bubble -->
  <div class="bubble-spot">
    <form class="bubble" action="#" method="get" onsubmit="return false">
      <textarea
        class="prompt"
        id="prompt-input"
        rows="1"
        autocomplete="off"
        autocapitalize="off"
        autocorrect="off"
        spellcheck="false"
        aria-label="Ask something"
        placeholder="Tell me to build something legendary…"
      ></textarea>

      <button class="send" type="button" aria-label="Send">
        <svg viewBox="0 0 24 24" aria-hidden="true">
          <path d="M12 19V5M12 5l-6 6M12 5l6 6"/>
        </svg>
      </button>
    </form>
  </div>

  <script>
    /* ===== Hero type-in lines (unchanged, polished) ===== */
    const SUGGESTIONS = [
      "Design a ruthless—but legal—negotiation script that cuts supplier prices 25%.",
      "Turn $10k into $100k in 12 months: step-by-step arbitrage game plan.",
      "Find the fastest path to 1,000 paying users for an AI app—zero fluff.",
      "Reverse-engineer my top competitor’s funnel and out-convert them by 30%.",
      "Automate cold outreach that feels human—deliver 10 booked calls per day.",
      "Blueprint a content flywheel that prints $50k/month in inbound leads.",
      "Identify 3 undervalued micro-SaaS buys under $2M we can acquire now.",
      "Draft a no-BS investor memo that raises $1M with traction-light signals.",
      "Ship a viral ONX launch that hits #1 on Product Hunt within 48 hours.",
      "Audit pricing and add a premium tier that lifts ARPU by 40%."
    ];

    const TYPER = { startDelay:500, type:34, hold:1600, gap:650, loop:true };

    (function initTypewriter(){
      const input  = document.getElementById('prompt-input');
      const bubble = document.querySelector('#chat-hero .bubble');
      const hero   = document.getElementById('chat-hero');
      if (!input || !bubble || !hero) return;

      input.addEventListener('keydown', e => e.preventDefault());
      input.addEventListener('beforeinput', e => e.preventDefault());

      function autosize(){
        input.style.height = 'auto';
        input.style.height = input.scrollHeight + 'px';
      }
      function syncBubbleH(){
        const h = bubble.getBoundingClientRect().height;
        hero.style.setProperty('--bubbleH', h + 'px');
      }

      const ro = new ResizeObserver(syncBubbleH);
      ro.observe(bubble);

      const reduceMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
      if (reduceMotion) {
        input.value = SUGGESTIONS[0] || "";
        autosize(); syncBubbleH();
        return;
      }

      let i = 0, j = 0;
      function typeNextChar(){
        const phrase = SUGGESTIONS[i] || "";
        input.classList.remove('is-fading');

        if (j < phrase.length){
          input.value += phrase[j++];
          autosize(); syncBubbleH();
          setTimeout(typeNextChar, TYPER.type);
        } else {
          setTimeout(() => fadeOutThenAdvance(), TYPER.hold);
        }
      }

      function fadeOutThenAdvance(){
        input.classList.add('is-fading');

        const onEnd = (e) => {
          if (e.propertyName && e.propertyName !== 'opacity') return;
          input.removeEventListener('transitionend', onEnd);

          input.value = "";
          autosize(); syncBubbleH();

          i = (i + 1) % SUGGESTIONS.length;
          j = 0;

          setTimeout(typeNextChar, TYPER.gap);
        };

        input.addEventListener('transitionend', onEnd, { once:true });
        setTimeout(() => {
          if (input.classList.contains('is-fading')) input.dispatchEvent(new Event('transitionend'));
        }, 1000);
      }

      input.value = "";
      autosize(); syncBubbleH();
      setTimeout(typeNextChar, TYPER.startDelay);

      window.addEventListener('resize', () => { autosize(); syncBubbleH(); });
    })();
  </script>
</section>
<!--======================================================================================================================================================================-->
<!--=====================================================================CHAT END=================================================================================================-->

<!--======================================================================== ORBIT SECTION (Apple-style, minimal) ===============================================================-->
<!-- ONX Orbit → Suck → Morph (O → O N X). Plays once, only when scrolled into view. -->
<style>
  /* Audiowide for the ONX wordmark (safe here so you can paste in <body>) */
  @import url("https://fonts.googleapis.com/css2?family=Audiowide&display=swap");

  /* ───────── Design tokens ───────── */
  .onx-merge{
    --bg:#ffffff; --ink:#0B0B0C;
    --stage-h:clamp(420px,78vh,980px);

    --size:min(58vmin,620px);            /* square anchor */
    --ring:calc(var(--size)*0.92);       /* orbit diameter */
    --o-font:clamp(72px,17vmin,220px);   /* “O/ONX” size */

    --logo:clamp(40px,6.2vmin,76px);     /* orbit chip size */
    --radius:calc(var(--ring)/2.06);     /* orbit radius */

    --spin-duration:8s;
    --intro-delay:900ms;                 /* after enter */
    --suck-duration:880ms;
    --suck-stagger:520ms;
    --reveal-gap:340ms;                  /* O bounce → NX wipe */
    --ease-out:cubic-bezier(.16,1,.3,1);
    --ease-inout:cubic-bezier(.2,.7,.2,1);

    --shadow-soft:0 2px 10px #00000018;
    --shadow-deep:0 16px 52px #00000012;

    position:relative; width:100%; height:var(--stage-h);
    background:var(--bg); color:var(--ink);
    display:grid; place-items:center;
    overflow:clip; isolation:isolate;
  }

  /* Subtle depth (very minimal, nearly imperceptible) */
  .onx-merge .onx-halo{
    position:absolute; inset:0; margin:auto;
    width:min(82vmin,780px); height:min(82vmin,780px);
    border-radius:50%;
    background:
      radial-gradient(42% 42% at 50% 50%, #0b0b0c0a, #0000 72%),
      radial-gradient(26% 26% at 58% 44%, #0b0b0c08, #0000 76%);
    filter:blur(0.8px); pointer-events:none; z-index:0;
    opacity:.85; transform:scale(1);
    transition:opacity 600ms var(--ease-out), transform 900ms var(--ease-out);
  }
  .onx-merge:not(.is-start) .onx-halo{opacity:0; transform:scale(1.03)}

  /* Center anchor */
  .onx-merge .center-lock{
    position:relative; width:var(--size); height:var(--size);
    display:grid; place-items:center; z-index:2; contain:layout paint size;
  }

  /* Wordmark */
  .onx-merge .onx-word{
    font-family:'Audiowide',system-ui,-apple-system,Segoe UI,Roboto,sans-serif;
    line-height:1; letter-spacing:.012em;
    filter:drop-shadow(var(--shadow-soft));
    pointer-events:none; position:relative; z-index:10;
    transform:translateX(var(--recenter,0px));
    transition:transform 560ms var(--ease-out);
    will-change:transform;
  }
  .onx-merge .glyph-o{
    font-size:var(--o-font); display:inline-block;
    will-change:transform,filter,letter-spacing;
  }
  .onx-merge .glyph-nx{
    font-size:var(--o-font);
    position:absolute; left:100%; top:0;
    margin-left:.08em; /* design gap (converted to px via JS) */
    opacity:0; transform:translateX(-0.18em);
    letter-spacing:.02em;
    -webkit-mask:linear-gradient(90deg,#0000 0%,#000 20% 100%);
            mask:linear-gradient(90deg,#0000 0%,#000 20% 100%);
    -webkit-mask-position:0% 50%; mask-position:0% 50%;
    -webkit-mask-size:220% 100%;   mask-size:220% 100%;
    transition:
      opacity 560ms var(--ease-out),
      transform 560ms var(--ease-out),
      letter-spacing 560ms var(--ease-out),
      -webkit-mask-position 760ms var(--ease-out);
  }

  /* Orbit ring */
  .onx-merge .onx-orbit{
    position:absolute; left:50%; top:50%;
    width:var(--ring); height:var(--ring);
    margin-left:calc(var(--ring)/-2); margin-top:calc(var(--ring)/-2);
    border-radius:50%; pointer-events:none; z-index:3;
    will-change:transform, opacity;
    opacity:0; transform:scale(.98);
    transition:opacity 600ms var(--ease-out), transform 600ms var(--ease-out);
  }
  .onx-merge.is-start .onx-orbit{
    opacity:1; transform:scale(1);
    animation:onx-spin var(--spin-duration) linear infinite;
  }
  @keyframes onx-spin{to{transform:rotate(360deg)}}

  .onx-merge .orbiter{position:absolute; left:50%; top:50%; width:1px; height:1px; transform-origin:0 0}

  /* Logos (chips) */
  .onx-merge .chip{
    position:relative; width:var(--logo); height:var(--logo);
    transform:translateX(var(--radius)) translate(-50%,-50%) scale(1);
    transform-origin:50% 50%;
    border-radius:14px;
    background:radial-gradient(120% 120% at 30% 20%, #fff 0%, #f8fafc 60%, #f2f4f8 100%);
    box-shadow:0 0 0 1px #0b0b0c12 inset, 0 10px 24px #00000014;
    overflow:hidden; will-change:transform,opacity,filter;
  }
  .onx-merge .chip::before{
    content:""; position:absolute; inset:0;
    background:radial-gradient(80% 80% at 50% 50%, #ffffff80, #ffffff00 70%);
    mix-blend-mode:screen; pointer-events:none;
  }
  .onx-merge .logo{position:absolute; inset:0; width:100%; height:100%; object-fit:contain; filter:saturate(1.05) contrast(1.02)}

  /* Suck-in */
  .onx-merge.is-suck .chip{
    animation:onx-suck var(--suck-duration) var(--ease-inout) forwards;
    animation-delay:var(--delay,0ms);
  }
  @keyframes onx-suck{
    0%{   opacity:1;   transform:translateX(var(--radius)) translate(-50%,-50%) scale(1) }
    60%{  opacity:.34; transform:translateX(0)             translate(-50%,-50%) scale(.46) }
    78%{  opacity:.20; transform:translateX(-10px)         translate(-50%,-50%) scale(.42) }
    90%{  opacity:.16; transform:translateX(4px)           translate(-50%,-50%) scale(.38) }
    100%{ opacity:0;   transform:translateX(0)             translate(-50%,-50%) scale(.28); filter:blur(1px) }
  }

  /* O bounce + spin */
  .onx-merge.is-reveal .glyph-o{
    animation:onx-o-spin 820ms var(--ease-inout) both, onx-o-bounce 820ms var(--ease-inout) both;
  }
  @keyframes onx-o-spin{to{transform:rotate(360deg)}}
  @keyframes onx-o-bounce{
    0%{   letter-spacing:.010em; filter:drop-shadow(var(--shadow-soft)); transform:scale(1) }
    54%{  letter-spacing:.024em; filter:drop-shadow(var(--shadow-deep)); transform:scale(1.08) }
    78%{  transform:scale(.985) }
    100%{ letter-spacing:.012em; filter:drop-shadow(var(--shadow-soft)); transform:scale(1) }
  }

  /* NX wipe-in */
  .onx-merge.is-reveal .glyph-nx{
    opacity:1; transform:translateX(0); letter-spacing:.012em;
    -webkit-mask-position:100% 50%; mask-position:100% 50%;
  }

  /* Orbit gently fades after reveal */
  .onx-merge.is-reveal .onx-orbit{opacity:0; transition:opacity 420ms var(--ease-out) 80ms}

  @media (prefers-reduced-motion:reduce){
    .onx-merge .onx-orbit{animation:none}
    .onx-merge .chip,
    .onx-merge .glyph-o,
    .onx-merge .glyph-nx{transition:none; animation-duration:.001ms !important; animation-iteration-count:1 !important}
  }
</style>

<section class="onx-merge" id="onx-merge" aria-label="ONX animation">
  <div class="onx-halo" aria-hidden="true"></div>

  <div class="center-lock">
    <!-- Wordmark (O morphs to O N X) -->
    <div class="onx-word" id="onx-word" aria-hidden="true">
      <span class="glyph-o" id="glyph-o">O</span>
      <span class="glyph-nx" id="glyph-nx">NX</span>
    </div>

    <!-- Orbiting AI logos — replace src values with your assets -->
    <div class="onx-orbit" id="onx-orbit" aria-hidden="true">
      <div class="orbiter"><div class="chip"><img class="logo" src="grokLogo.svg"   alt="Grok"></div></div>
      <div class="orbiter"><div class="chip"><img class="logo" src="googleLogo.svg" alt="Google"></div></div>
      <div class="orbiter"><div class="chip"><img class="logo" src="metaLogo.svg"   alt="Meta"></div></div>
      <div class="orbiter"><div class="chip"><img class="logo" src="OAILogo.png"    alt="OpenAI"></div></div>
    </div>
  </div>
</section>

<script>
/* ONX Orbit → Suck → Morph (plays once when in view) */
(function(){
  const root     = document.getElementById('onx-merge');
  if(!root || root.dataset.init) return; root.dataset.init='1';

  const word     = document.getElementById('onx-word');
  const nxEl     = document.getElementById('glyph-nx');
  const orbit    = document.getElementById('onx-orbit');
  const orbiters = Array.from(orbit.querySelectorAll('.orbiter'));
  const chips    = Array.from(root.querySelectorAll('.chip'));

  const css  = p => getComputedStyle(root).getPropertyValue(p).trim();
  const toMs = v => v.endsWith('ms') ? parseFloat(v) : v.endsWith('s') ? parseFloat(v)*1000 : parseFloat(v)||0;

  const INTRO_DELAY   = toMs(css('--intro-delay'))   || 900;
  const STAGGER       = toMs(css('--suck-stagger'))  || 520;
  const SUCK_DURATION = toMs(css('--suck-duration')) || 880;
  const REVEAL_GAP    = toMs(css('--reveal-gap'))    || 340;

  let started = false;
  let timers  = [];

  // 1) Evenly distribute orbiters around circle (no nth-child assumptions)
  function distributeOrbiters(){
    const n = orbiters.length;
    const offset = -90; // put one at the top (hero feel)
    orbiters.forEach((el,i)=>{
      const angle = offset + (360/n)*i;
      el.style.transform = `rotate(${angle}deg)`;
    });
  }
  distributeOrbiters();

  // 2) Compute NX gap → keep “ONX” centered when NX appears
  function computeRecenter(){
    const s = getComputedStyle(nxEl);
    const gapEm = parseFloat(s.marginLeft||'0') || 0;
    const temp = document.createElement('span');
    temp.style.font = getComputedStyle(word).font;
    temp.textContent = 'M';
    temp.style.visibility='hidden';
    document.body.appendChild(temp);
    const emPx = temp.getBoundingClientRect().width; document.body.removeChild(temp);
    const gapPx = gapEm * emPx;
    const nxWidth = nxEl.getBoundingClientRect().width || 0;
    const delta = nxWidth + gapPx;
    word.style.setProperty('--recenter', (-delta/2)+'px');
  }

  // 3) Stagger chip “suck” delays (relative to .is-suck class time)
  chips.forEach((el,i)=> el.style.setProperty('--delay', (i*STAGGER)+'ms'));

  // 4) Start timeline (only once)
  async function start(){
    if(started) return; started = true;

    // Respect reduced motion: instantly reveal
    const reduced = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
    root.classList.add('is-start');
    if(reduced){
      computeRecenter();
      root.classList.add('is-reveal');
      orbit.style.opacity = '0';
      root.setAttribute('aria-label','ONX');
      return;
    }

    // Small intro settle
    timers.push(setTimeout(()=> {
      root.classList.add('is-suck'); // triggers per-chip animation with --delay
    }, INTRO_DELAY));

    // When last chip finishes + small gap → reveal ONX
    const lastAbsorbEndsAt = INTRO_DELAY + ((chips.length-1)*STAGGER) + SUCK_DURATION + REVEAL_GAP;

    // Ensure fonts are ready to measure precisely
    try{ if(document.fonts && document.fonts.ready) await document.fonts.ready; }catch(e){}

    timers.push(setTimeout(()=>{
      computeRecenter();
      root.classList.add('is-reveal');
      root.setAttribute('aria-label','ONX');
    }, lastAbsorbEndsAt));
  }

  // IntersectionObserver: play once when ~45% visible
  const io = new IntersectionObserver((entries)=>{
    for(const e of entries){
      if(e.isIntersecting && e.intersectionRatio >= 0.45){ start(); io.disconnect(); break; }
    }
  }, {threshold:[0, .25, .45, .75, 1]});
  io.observe(root);

  // Cleanup on page hide (optional)
  document.addEventListener('visibilitychange', ()=> {
    if(document.hidden){ timers.forEach(t=>clearTimeout(t)); timers.length=0; }
  }, {passive:true});

  // Recompute recenter on resize if already revealed (robust on rotation)
  addEventListener('resize', ()=>{
    if(root.classList.contains('is-reveal')) computeRecenter();
  }, {passive:true});
})();
</script>


<!--=========================================================================SHOWCASE VIDEO SECTION=============================================================================================-->
<!-- ──────────────────────────Showcase Video Section───────────────────────────────────── -->
<!-- ONX Card Reveal → Chat Bubble — center-out card, then boomerang morph to pill with blinking caret -->
<div id="onx-card-reveal" class="padTop"
     data-speed="1.6"
     data-menu-scale="1.5"
     data-overshoot-x-enabled="false"
     data-overshoot-y-enabled="true"
     data-overshoot-x="1.5"
     data-overshoot-y="1.5"
     data-peak-x="0.58"
     data-peak-y="0.60"
     style="max-width:100%; margin:0 auto;">

  <style>
    #onx-card-reveal * { box-sizing: border-box; }
    #onx-stage{
      position:relative; width:min(900px,92vw); aspect-ratio:16/9; margin:0 auto;
      border-radius:28px; overflow:hidden;
      /* Stage background comes from gradient utility classes below */
      box-shadow: none;
      will-change: transform;
      transform-origin:center top; /* mobile will scale from top-center */
    }
    #onx-stage canvas{width:100%; height:100%; display:block;}
     #onx-controls{
      display:flex; gap:8px; justify-content:center; align-items:center; margin-top:14px;
      font-family: ui-sans-serif,-apple-system,BlinkMacSystemFont,"SF Pro Display",Inter,system-ui;
      touch-action: manipulation;
    }
    #onx-controls button{
      border:0; border-radius:999px; padding:10px 16px; cursor:pointer;
      background:#000; color:#fff; font-weight:600; letter-spacing:.2px;
      box-shadow:0 6px 18px rgba(0,0,0,.12);
      transition:transform .15s ease, box-shadow .2s ease;
    }
    #onx-controls button:hover{ transform:translateY(-1px); box-shadow:0 10px 26px rgba(0,0,0,.18); }
    #onx-controls button:disabled{ opacity:.45; cursor:not-allowed; transform:none; }

    /* MOBILE ONLY */
    @media (max-width: 640px){
      #onx-card-reveal{ overflow:hidden; margin:24px auto 28px; }
      #onx-controls{ margin-top:10px; }
      #onx-controls button{ padding:9px 14px; font-size:14px; }
    }
  </style>

  <!-- Gradient/animation lives on the stage container -->
  <div id="onx-stage" class="g-grad grad-animi"><canvas id="onx-canvas"></canvas></div>

  <div id="onx-controls"></div> 
  <div id="onx-play"></div> 

  <script>
    (()=>{ 'use strict';

      // ===== ELEMENTS =====
      const host    = document.getElementById('onx-card-reveal');
      const stageEl = document.getElementById('onx-stage');
      const canvas  = document.getElementById('onx-canvas');

      // ===== UTILS =====
      const toBool = v => ['1','true','on','yes'].includes(String(v).toLowerCase().trim());
      const ASPECT = 16/9;

      const isMobile = () =>
        window.matchMedia('(max-width: 640px)').matches || ('ontouchstart' in window);

      const vp = () => {
        const vv = window.visualViewport;
        if (vv) return { vw: Math.max(320, vv.width), vh: Math.max(320, vv.height), top: vv.offsetTop||0, bottom: (window.innerHeight - vv.height - (vv.offsetTop||0)) };
        return { vw: Math.max(320, window.innerWidth || 360), vh: Math.max(320, window.innerHeight || 640), top: 0, bottom: 0 };
      };

      // ===== OPTIONS =====
      const TEMPO = {
        speed: parseFloat(host.dataset.speed) || 1.6,
        menuScale: parseFloat(host.dataset.menuScale) || 1.5,
        overshootXEnabled: host.dataset.overshootXEnabled !== undefined ? toBool(host.dataset.overshootXEnabled) : false,
        overshootYEnabled: host.dataset.overshootYEnabled !== undefined ? toBool(host.dataset.overshootYEnabled) : true,
        overshootX: parseFloat(host.dataset.overshootX) || 1.5,
        overshootY: parseFloat(host.dataset.overshootY) || 1.5,
        peakX: parseFloat(host.dataset.peakX) || 0.58,
        peakY: parseFloat(host.dataset.peakY) || 0.60
      };

      // ===== CANVAS CONFIG (mobile perf caps) =====
      let CONFIG = isMobile() ? { w: 1024, h: 576 } : { w: 1920, h: 1080 }; // 16:9
      const dprRaw = window.devicePixelRatio || 1;
      let dpr = isMobile() ? Math.min(1.15, dprRaw) : Math.max(1, dprRaw);

      canvas.width  = CONFIG.w * dpr;
      canvas.height = CONFIG.h * dpr;
      const ctx = canvas.getContext('2d', { alpha: true, desynchronized: true });
      ctx.scale(dpr, dpr);
      ctx.imageSmoothingEnabled = true;

      // Transparent BG buffer (kept for structure; now just clears)
      let BG_CANVAS = document.createElement('canvas');
      BG_CANVAS.width = CONFIG.w; BG_CANVAS.height = CONFIG.h;
      let BG_CTX = BG_CANVAS.getContext('2d');
      (function cacheBG(){
        BG_CTX.clearRect(0,0,CONFIG.w,CONFIG.h); // fully transparent
      })();

      // Helper: clear the main canvas every frame (prevents trails)
      function clearStage(){
        ctx.setTransform(1,0,0,1,0,0);
        ctx.clearRect(0,0,CONFIG.w * dpr, CONFIG.h * dpr);
        ctx.setTransform(dpr,0,0,dpr,0,0);
      }

      // ===== DESIGN BASE / STYLE (recomputable) =====
      const DESIGN = {
        padX: 20, padY: 20, rowGap: 16, subGap: 6,
        titleSize: 28, subSize: 18, titleWeight: 800, subWeight: 500,
        minW: 360, maxW: 720, stageMargin: 56
      };
      const getMenuScale = () => isMobile() ? Math.min(TEMPO.menuScale, 1.25) : TEMPO.menuScale;

      let STYLE = buildStyle();
      function buildStyle(){
        const SCALE = getMenuScale();
        return {
          padX: Math.round(DESIGN.padX * SCALE),
          padY: Math.round(DESIGN.padY * SCALE),
          rowGap: Math.round(DESIGN.rowGap * SCALE),
          subGap: Math.max(2, Math.round(DESIGN.subGap * SCALE)),
          titleSize: DESIGN.titleSize * SCALE,
          subSize: DESIGN.subSize * SCALE,
          titleWeight: DESIGN.titleWeight,
          subWeight: DESIGN.subWeight,
          minW: DESIGN.minW * SCALE,
          maxW: DESIGN.maxW * SCALE,
          stageMargin: isMobile() ? Math.max(20, Math.round(DESIGN.stageMargin * 0.8)) : DESIGN.stageMargin
        };
      }

      // ===== MODELS (content unchanged) =====
      const rows = [
        { title:'ONX FAST', sub:'Fastest for instant answers' },
        { title:'ONX',      sub:'Default model' },
        { title:'ONX PRO',  sub:'Advanced agentic capabilities' },
      ];

      // ===== HELPERS =====
      const clamp=(v,lo=0,hi=1)=>Math.min(hi,Math.max(lo,v));
      const lerp=(a,b,t)=>a+(b-a)*t;
      const easeOutCubic=t=>1-Math.pow(1-clamp(t,0,1),3);
      const easeInOutCubic=t=>t<.5?4*t*t*t:1-Math.pow(-2*t+2,3)/2;
      function boomerang(t, factor=1.10, peak=0.55){
        if (t <= 0) return 0;
        if (t >= 1) return 1;
        if (t < peak) return easeOutCubic(t/peak) * factor;
        const u = (t - peak) / (1 - peak);
        return 1 + (factor - 1) * (1 - easeOutCubic(u));
      }
      function setFont(weight,size){
        ctx.font = `${weight} ${size}px ui-sans-serif, -apple-system, BlinkMacSystemFont, "SF Pro Display", Inter, system-ui`;
      }
      function roundedRect(ctx,x,y,w,h,r){
        const rr=Math.min(r,w/2,h/2);
        ctx.beginPath();
        ctx.moveTo(x+rr,y);
        ctx.arcTo(x+w,y,x+w,y+h,rr);
        ctx.arcTo(x+w,y+h,x,y+h,rr);
        ctx.arcTo(x,y+h,x,y,rr);
        ctx.arcTo(x,y,x+w,y,rr);
        ctx.closePath();
      }

      // ===== TIMINGS =====
      const BASE = { widthGrow: 0.65, rowPop: 0.42, rowPause: 0.30, holdA: 0.34, holdB: 0.50, morph: 0.95 };
      const S = v => v / TEMPO.speed;

      // ===== LAYOUT =====
      function measureFinalLayout(){
        let maxTextW = 0;
        setFont(800, STYLE.titleSize);
        rows.forEach(r=>{ maxTextW = Math.max(maxTextW, ctx.measureText(r.title).width); });
        setFont(500, STYLE.subSize);
        rows.forEach(r=>{ if (r.sub) maxTextW = Math.max(maxTextW, ctx.measureText(r.sub).width); });

        const contentW = Math.ceil(maxTextW);
        const cardW = Math.min(
          clamp(contentW + STYLE.padX*2, STYLE.minW, STYLE.maxW),
          CONFIG.w - 2*STYLE.stageMargin
        );

        const rowHeights = rows.map(r => STYLE.titleSize + (r.sub ? (STYLE.subGap + STYLE.subSize) : 0));
        const contentH = rowHeights.reduce((a,b)=>a+b,0) + STYLE.rowGap*(rows.length-1);
        const cardH = Math.min(
          Math.ceil(contentH + STYLE.padY*2),
          CONFIG.h - 2*STYLE.stageMargin
        );

        const radius = Math.max(22, Math.min(36, Math.round(Math.min(cardW, cardH) * 0.08)));
        return { cardW, cardH, rowHeights, radius };
      }
      let layout = measureFinalLayout();

      // Seed shape
      const seed = { w: 120, h: 80, r: 20 };

      // Row schedule
      const ROW_POP_DUR = S(BASE.rowPop);
      const ROW_PAUSE   = S(BASE.rowPause);
      const rowStartTimes = rows.map((_, i) => i * (ROW_POP_DUR + ROW_PAUSE));

      // MOBILE tuning
      const MOBILE_SHADOW_SCALE = isMobile() ? 0.7 : 1.0;
      const MOBILE_BLUR_SCALE   = isMobile() ? 0.6 : 1.0;

      // ===== MOBILE AUTO-FIT SCALE =====
      function controlHeight(){
        const ctrl = document.getElementById('onx-controls');
        return ctrl ? Math.max(0, ctrl.offsetHeight || 44) : 44;
      }
      function applyMobileScale(){
        if (!isMobile()){
          stageEl.style.transform = '';
          stageEl.style.transformOrigin = 'center top';
          return;
        }
        const { vw, vh, top, bottom } = vp();
        const safeSide = 16;
        const safeTop  = 16 + top;
        const safeBot  = 16 + bottom;
        const ctrlH    = controlHeight();
        const hostMargins = 24 + 28;

        const baseW = Math.min(900, 0.92 * vw);
        const baseH = baseW / ASPECT;

        const availW = Math.max(240, vw - 2*safeSide);
        const availH = Math.max(200, vh - safeTop - safeBot - ctrlH - hostMargins);

        const scaleW = availW / baseW;
        const scaleH = availH / baseH;
        const desired = 2.0;
        const scale = Math.max(0.6, Math.min(desired, scaleW, scaleH));

        stageEl.style.transform = `scale(${scale})`;
        stageEl.style.transformOrigin = 'center top';
      }

      // --------- Phase A: Card build ----------
      function renderCard(t){
        clearStage();                       // <— crucial: clear frame
        ctx.drawImage(BG_CANVAS, 0, 0);     // transparent buffer (no fill)

        const widthEnd = S(BASE.widthGrow);
        const tw = clamp(t / widthEnd);
        const widthScale  = TEMPO.overshootXEnabled ? boomerang(tw, TEMPO.overshootX, TEMPO.peakX) : easeInOutCubic(tw);

        const w = lerp(seed.w, layout.cardW, Math.min(widthScale, TEMPO.overshootXEnabled ? TEMPO.overshootX : 1));

        let contentVisibleH = 0, visibleRows = 0, poppingIndex = -1, poppingProgress = 0;
        for (let i=0; i<rows.length; i++){
          const local = (t - rowStartTimes[i]) / ROW_POP_DUR;
          if (local <= 0) break;
          visibleRows++;
          if (local < 1){
            poppingIndex = i;
            poppingProgress = clamp(local);
            const rowScale = boomerang(poppingProgress, 1.08, 0.55);
            contentVisibleH += layout.rowHeights[i] * rowScale;
          } else {
            contentVisibleH += layout.rowHeights[i];
          }
        }
        if (visibleRows > 1) contentVisibleH += STYLE.rowGap * (visibleRows - 1);

        let springY = 1;
        if (poppingIndex >= 0) springY = boomerang(poppingProgress, 1.06, 0.5);

        const h = Math.max(
          seed.h,
          Math.min(Math.ceil(contentVisibleH * springY + STYLE.padY*2), CONFIG.h - 2*STYLE.stageMargin)
        );

        const growT = clamp((w - seed.w) / Math.max(1, layout.cardW - seed.w));
        const r = lerp(seed.r, layout.radius, easeOutCubic(growT));
        const x = (CONFIG.w - w)/2, y = (CONFIG.h - h)/2;

        // Card
        ctx.shadowColor = `rgba(0,0,0,${lerp(.10,.17,growT)})`;
        ctx.shadowBlur = lerp(6, 26, growT) * MOBILE_SHADOW_SCALE;
        ctx.shadowOffsetY = lerp(6, 15, growT);
        ctx.fillStyle = '#ffffff';
        roundedRect(ctx, x, y, w, h, r); ctx.fill();
        ctx.shadowColor='transparent';
        ctx.lineWidth = 1; ctx.strokeStyle = 'rgba(0,0,0,0.06)'; ctx.stroke();

        // Content
        ctx.save(); roundedRect(ctx, x, y, w, h, r); ctx.clip();
        const contentX = x + STYLE.padX;
        let cursorY = y + STYLE.padY;

        for (let i=0; i<rows.length; i++){
          const local = (t - rowStartTimes[i]) / ROW_POP_DUR;
          if (local <= 0) break;

          const pr = clamp(local);
          const a  = easeOutCubic(pr);
          const s  = 1 - (1 - boomerang(pr, 1.08, 0.55)) * 0.06;
          const dy = lerp(10, 0, a);
          const blurPx = (1 - a) * 1.5 * MOBILE_BLUR_SCALE;

          ctx.save();
          ctx.translate(contentX, cursorY + dy);
          ctx.scale(s, s);
          ctx.textAlign = 'left'; ctx.textBaseline = 'alphabetic';
          ctx.globalAlpha = a;
          if (blurPx > 0.05) ctx.filter = `blur(${blurPx}px)`;

          setFont(STYLE.titleWeight, STYLE.titleSize);
          ctx.fillStyle = '#0b0b10';
          ctx.fillText(rows[i].title, 0, STYLE.titleSize);

          if (rows[i].sub){
            setFont(STYLE.subWeight, STYLE.subSize);
            ctx.fillStyle = '#5f646c';
            ctx.fillText(rows[i].sub, 0, STYLE.titleSize + STYLE.subGap + STYLE.subSize);
          }
          ctx.filter = 'none'; ctx.globalAlpha = 1; ctx.restore();

          cursorY += layout.rowHeights[i] + STYLE.rowGap;
        }
        ctx.restore();

        const lastEnd = rowStartTimes[rows.length - 1] + ROW_POP_DUR;
        const total = lastEnd + S(BASE.holdA) + S(BASE.holdB);
        return { total, x, y, w, h, r };
      }

      // --------- Phase B: Morph card → chat bubble ----------
      function renderMorphCardToBubble(startBox, t){
        clearStage();                    // <— clear frame
        ctx.drawImage(BG_CANVAS, 0, 0);  // transparent buffer

        const mobile = isMobile();

        const maxBubbleW = CONFIG.w - 2*STYLE.stageMargin;
        const targetBubbleW = mobile
          ? Math.min(maxBubbleW, Math.max(520, startBox.w * 1.35))
          : Math.max(startBox.w * 1.8, 1100);
        const bubbleW = Math.round(Math.min(maxBubbleW, targetBubbleW));
        const bubbleH = Math.round(mobile ? Math.min(96, 104) : Math.min(100 * getMenuScale(), 130));
        const bubbleR = Math.round(bubbleH / 2);

        const widthF  = TEMPO.overshootXEnabled ? boomerang(t, TEMPO.overshootX, TEMPO.peakX) : easeInOutCubic(t);
        const heightF = TEMPO.overshootYEnabled ? boomerang(t, TEMPO.overshootY, TEMPO.peakY) : easeInOutCubic(t);
        const radiusF = easeInOutCubic(t);

        const w = startBox.w + (bubbleW - startBox.w) * widthF;
        const h = startBox.h + (bubbleH - startBox.h) * heightF;
        const r = startBox.r + (bubbleR - startBox.r) * radiusF;
        const x = (CONFIG.w - w)/2;
        const y = (CONFIG.h - h)/2 + 30 * radiusF;

        // Shape
        ctx.shadowColor = `rgba(0,0,0,${lerp(.14,.16, radiusF)})`;
        ctx.shadowBlur = lerp(12, 22, radiusF) * MOBILE_SHADOW_SCALE;
        ctx.shadowOffsetY = lerp(10, 14, radiusF);
        ctx.fillStyle = '#ffffff';
        roundedRect(ctx, x, y, w, h, r); ctx.fill();
        ctx.shadowColor='transparent';
        ctx.lineWidth = 1; ctx.strokeStyle = 'rgba(0,0,0,0.06)'; ctx.stroke();

        // Fade out ghost rows
        const contentFadeOut = 1 - clamp(t / 0.25);
        if (contentFadeOut > 0){
          ctx.save();
          roundedRect(ctx, x, y, w, h, r); ctx.clip();
          const contentX = x + STYLE.padX, contentTop = y + STYLE.padY;
          setFont(STYLE.titleWeight, STYLE.titleSize);
          ctx.globalAlpha = 0.4 * contentFadeOut; ctx.fillStyle = '#0b0b10';
          const ghostLines = Math.min(3, rows.length);
          for (let i=0;i<ghostLines;i++){
            let yRow = contentTop;
            for (let j=0;j<i;j++) yRow += layout.rowHeights[j] + STYLE.rowGap;
            ctx.fillText(rows[i].title, contentX, yRow + STYLE.titleSize);
          }
          ctx.restore();
        }

        // Minimal UI bits at end (desktop only)
        const uiAlpha = clamp((t - 0.6)/0.25);
        if (uiAlpha > 0 && !mobile){
          const plusCx = x + 28, plusCy = y + h/2;
          ctx.save();
          ctx.globalAlpha = uiAlpha;
          ctx.strokeStyle = '#0b0b0f'; ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(plusCx-7, plusCy); ctx.lineTo(plusCx+7, plusCy);
          ctx.moveTo(plusCx, plusCy-7); ctx.lineTo(plusCx, plusCy+7);
          ctx.stroke();
          const micCx = x + w - 36, micCy = y + h/2;
          ctx.beginPath(); ctx.fillStyle = 'rgba(0,0,0,0.06)'; ctx.arc(micCx, micCy, 14, 0, Math.PI*2); ctx.fill();
          ctx.beginPath(); ctx.fillStyle = '#0b0b0f'; ctx.arc(micCx, micCy, 5, 0, Math.PI*2); ctx.fill();
          ctx.restore();
        }

        const bx = (CONFIG.w - bubbleW)/2;
        const by = (CONFIG.h - bubbleH)/2 + 30;
        return { w, h, x, y, r, bubble: { w: bubbleW, h: bubbleH, x: bx, y: by, r: bubbleR }, uiAlpha };
      }

      // --------- Phase C: Idle bubble with blinking caret ----------
      let caretLoop = null;
      function startBubbleIdle(bubble){
        let rafId = null;
        const caretPeriod = 900; // ms
        const mobile = isMobile();

        function loop(nowMS){
          clearStage();                  // <— clear frame
          ctx.drawImage(BG_CANVAS, 0, 0);

          // Bubble
          ctx.shadowColor = 'rgba(0,0,0,0.15)';
          ctx.shadowBlur = 20 * MOBILE_SHADOW_SCALE; ctx.shadowOffsetY = 14;
          ctx.fillStyle = '#ffffff';
          roundedRect(ctx, bubble.x, bubble.y, bubble.w, bubble.h, bubble.r); ctx.fill();
          ctx.shadowColor='transparent';
          ctx.lineWidth = 1; ctx.strokeStyle = 'rgba(0,0,0,0.06)'; ctx.stroke();

          // Icons (desktop only)
          if (!mobile){
            const plusCx = bubble.x + 28, plusCy = bubble.y + bubble.h/2;
            ctx.save(); ctx.strokeStyle = '#0b0b0f'; ctx.lineWidth = 2;
            ctx.beginPath(); ctx.moveTo(plusCx-7, plusCy); ctx.lineTo(plusCx+7, plusCy);
            ctx.moveTo(plusCx, plusCy-7); ctx.lineTo(plusCx, plusCy+7); ctx.stroke();
            const micCx = bubble.x + bubble.w - 36, micCy = bubble.y + bubble.h/2;
            ctx.beginPath(); ctx.fillStyle = 'rgba(0,0,0,0.06)'; ctx.arc(micCx, micCy, 14, 0, Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.fillStyle = '#0b0b0f'; ctx.arc(micCx, micCy, 5, 0, Math.PI*2); ctx.fill();
            ctx.restore();
          }

          // Placeholder text + caret
          const textLeft = mobile ? (bubble.x + 20) : (bubble.x + 56);
          const textY = bubble.y + bubble.h/2 + (mobile ? 8 : 10);
          const baseText = 'Ask the impossible';
          setFont(600, mobile ? Math.max(16, 16 * getMenuScale()) : Math.max(18, 18 * getMenuScale()));
          ctx.fillStyle = '#8a8f96';
          ctx.fillText(baseText, textLeft, textY);

          const showCaret = Math.floor((nowMS % (caretPeriod)) / (caretPeriod/2)) === 0;
          if (showCaret){
            const textWidth = ctx.measureText(baseText).width;
            const cx = textLeft + textWidth + 6;
            const caretH = mobile ? 20 : 24;
            const cy = bubble.y + bubble.h/2 - caretH/2;
            ctx.fillStyle = '#8a8f96';
            ctx.fillRect(cx, cy, 2, caretH);
          }
          rafId = requestAnimationFrame(loop);
        }
        rafId = requestAnimationFrame(loop);
        caretLoop = { stop: ()=> cancelAnimationFrame(rafId) };
      }

      // --------- Orchestrator ----------
      let isAnimating = false;
      let waitTimer = null;

      function play(){
        if (isAnimating) return;
        isAnimating = true;
        if (caretLoop){ caretLoop.stop(); caretLoop = null; }
        if (waitTimer){ clearTimeout(waitTimer); waitTimer = null; }

        const btn = document.getElementById('onx-play'); if (btn) btn.disabled = true;
        const start = performance.now();

        function stepA(now){
          const t = (now - start)/1000;
          const A = renderCard(t);
          if (t < A.total){ requestAnimationFrame(stepA); }
          else {
            const finalBox = { x:A.x, y:A.y, w:A.w, h:A.h, r:A.r };
            waitTimer = setTimeout(()=>{
              const morphStart = performance.now();
              function stepB(now2){
                const t2 = (now2 - morphStart)/1000 / S(BASE.morph);
                const B = renderMorphCardToBubble(finalBox, clamp(t2));
                if (t2 < 1){ requestAnimationFrame(stepB); }
                else {
                  startBubbleIdle({ x: B.bubble.x, y: B.bubble.y, w: B.bubble.w, h: B.bubble.h, r: B.bubble.r });
                  isAnimating = false; if (btn) btn.disabled = false;
                }
              }
              requestAnimationFrame(stepB);
            }, 1000);
          }
        }
        requestAnimationFrame(stepA);
      }

      // First static frame (clean)
      clearStage();
      renderCard(0);

      // Manual controls
      document.getElementById('onx-play').addEventListener('click', play, { passive: true });

      // Autoplay when section center visible
      let autoplayed = false;
      function centerIsVisible(el){
        const rect = el.getBoundingClientRect();
        const vpCenterY = (window.visualViewport ? window.visualViewport.height : window.innerHeight) / 2;
        return (vpCenterY >= rect.top && vpCenterY <= rect.bottom);
      }
      function tryAutoplay(){
        if (!autoplayed && !isAnimating && centerIsVisible(stageEl)) {
          autoplayed = true;
          play();
        }
      }
      const io = new IntersectionObserver((entries)=>{
        for (const e of entries){ if (e.isIntersecting) tryAutoplay(); }
      }, { root: null, threshold: 0.1 });
      io.observe(stageEl);

      // Initial mobile fit
      applyMobileScale();

      // Resize / orientation / viewport chrome changes
      let rid = null;
      function rebuildIfNeeded(){
        applyMobileScale();

        const NOW_MOBILE = isMobile();
        const newCONFIG = NOW_MOBILE ? { w:1024, h:576 } : { w:1920, h:1080 };
        const newDPR = NOW_MOBILE ? Math.min(1.15, window.devicePixelRatio || 1) : Math.max(1, window.devicePixelRatio || 1);

        if (newCONFIG.w !== CONFIG.w || newCONFIG.h !== CONFIG.h || Math.abs(newDPR - dpr) > 0.001){
          CONFIG = newCONFIG; dpr = newDPR;
          canvas.width = CONFIG.w * dpr; canvas.height = CONFIG.h * dpr;
          ctx.setTransform(1,0,0,1,0,0); ctx.scale(dpr, dpr);

          // Rebuild transparent BG buffer
          BG_CANVAS.width = CONFIG.w; BG_CANVAS.height = CONFIG.h;
          BG_CTX = BG_CANVAS.getContext('2d');
          BG_CTX.clearRect(0,0,CONFIG.w,CONFIG.h);
        }

        // Update style & layout
        STYLE = buildStyle();
        layout = measureFinalLayout();

        clearStage();
        renderCard(0);
        tryAutoplay();
      }

      window.addEventListener('resize', ()=>{
        if (caretLoop){ caretLoop.stop(); caretLoop = null; }
        cancelAnimationFrame(rid);
        rid = requestAnimationFrame(rebuildIfNeeded);
      }, { passive: true });

      if (window.visualViewport){
        window.visualViewport.addEventListener('resize', ()=>{
          cancelAnimationFrame(rid);
          rid = requestAnimationFrame(rebuildIfNeeded);
        }, { passive: true });
        window.visualViewport.addEventListener('scroll', ()=>{
          cancelAnimationFrame(rid);
          rid = requestAnimationFrame(applyMobileScale);
        }, { passive: true });
      }

      window.addEventListener('scroll', tryAutoplay, { passive: true });
    })();
  </script>
</div>



<!--======================================================================================================================================================================-->
<!-- ──────────────────────────Become Limitless Section───────────────────────────────────── -->

<!-- ===============================
     ONX Models — DROP-IN SECTION
     =============================== -->
<section id="oc-Models" class="padTop section-clip relative mx-auto max-w-[1200px] oc-container reveal">
  <!-- Soft background glows (subtle, Apple-y) -->
  <div aria-hidden="true" class="pointer-events-none absolute inset-0 -z-10">
  <div class="absolute inset-0 bg-white"></div>
</div>


  <!-- Header -->
  <div class="w-full text-center">
    <h2 class=" text-oc-ink text-4xl md:text-6xl lg:text-7xl font-semibold tracking-tight grad-text"
        style="--from:#0B1B2Bcc; --via:#0E6F5Ccc; --to:#00CFFFcc; --speed:16s; --angle:135deg;">
      Become Limitless
    </h2>

    <p class="mx-auto mt-4 max-w-[780px] text-[20px] leading-relaxed text-neutral-600">
      ONX keeps you sharp. ONX Pro makes you unstoppable.
      <!-- <button id="ocModelsOpenBtnTop" class="ml-1 underline decoration-neutral-300 underline-offset-4 hover:text-neutral-900 focus:outline-none focus-visible:ring-2 focus-visible:ring-oc-accent rounded-sm">
        Models Library
      </button> -->
    </p>
  </div>

  <!-- Cards -->
  <!-- Centered, auto-fit columns with fixed track widths; items stretch to equal height -->
  <div class="mt-8 grid grid-cols-[repeat(auto-fit,minmax(280px,360px))] justify-center gap-4 md:gap-6 auto-rows-auto place-items-stretch">
    <!-- ONX (SWAPPED to white style like previous Coming Soon) -->
    <article
      class="group rounded-2xl border border-neutral-200 bg-white p-6 md:p-7 shadow-[0_10px_30px_rgba(0,0,0,.06)] scroll-fade tilt transition-shadow duration-300 hover:shadow-[0_14px_36px_rgba(0,0,0,.08)] flex flex-col">
      <div class="flex items-center gap-3">
        <h3 class="text-xl font-semibold tracking-tight text-neutral-900">ONX</h3>
      </div>
      <p class="mt-3 text-sm leading-relaxed text-neutral-700">
        Your essential AI — general reasoning, restrictions, and execution.
      </p>
      <ul class="mt-4 space-y-2 text-sm text-neutral-800/90">
        <li class="flex items-start gap-2"><i class="ph ph-check text-[18px] mt-[2px]" aria-hidden="true"></i><span>Limited cloud power.</span></li>
        <li class="flex items-start gap-2"><i class="ph ph-check text-[18px] mt-[2px]" aria-hidden="true"></i><span>Unlimited free local AI.</span></li>
        <li class="flex items-start gap-2"><i class="ph ph-check text-[18px] mt-[2px]" aria-hidden="true"></i><span>Local database creation.</span></li>
      </ul>
      <!-- CTA -->
      <div class="mt-6">
        <button
          id="ctaGetOC"
          type="button"
          aria-label="Get ONX"
          class="w-full h-11 inline-flex items-center justify-center rounded-xl bg-neutral-900 text-white text-sm font-medium tracking-tight shadow-sm ring-1 ring-black/10 hover:bg-neutral-800 hover:shadow-md active:bg-neutral-900/90 focus:outline-none focus-visible:ring-2 focus-visible:ring-neutral-900/40 transition">
          Get ONX
        </button>
      </div>
    </article>

    <!-- ONX PRO (black with white accents + Apple-grade sheen) -->
    <article
      class="group pro-card sheen rounded-2xl border border-white/10 bg-neutral-950 text-white p-6 md:p-7 shadow-[0_16px_54px_rgba(0,0,0,.30)] scroll-fade tilt transition-shadow duration-300 hover:shadow-[0_20px_64px_rgba(0,0,0,.40)] flex flex-col overflow-hidden">
      <div class="flex items-center gap-3">
        <h3 class="text-xl font-semibold tracking-tight">ONX PRO</h3>
      </div>
      <p class="mt-3 text-sm leading-relaxed text-white/85">
        Uncensored intelligence for pros — deeper reasoning, larger context, faster responses.
      </p>
      <ul class="mt-4 space-y-2 text-sm text-white/90">
        <li class="flex items-start gap-2"><i class="ph ph-check text-[18px] mt-[2px]" aria-hidden="true"></i><span>Utilize cloud power.</span></li>
        <li class="flex items-start gap-2"><i class="ph ph-check text-[18px] mt-[2px]" aria-hidden="true"></i><span>Private databases for accurate knowledge.</span></li>
        <li class="flex items-start gap-2"><i class="ph ph-check text-[18px] mt-[2px]" aria-hidden="true"></i><span>Uncensored to remove all limits.</span></li>
        <li class="flex items-start gap-2"><i class="ph ph-check text-[18px] mt-[2px]" aria-hidden="true"></i><span>Access to agentic assistant.</span></li>
      </ul>
      <!-- CTA -->
      <div class="mt-6">
        <button
          id="ctaGetOCPro"
          type="button"
          aria-label="Get ONX PRO"
          class="w-full h-11 inline-flex items-center justify-center rounded-xl bg-white text-neutral-950 text-sm font-medium tracking-tight shadow-sm ring-1 ring-white/20 hover:bg-white/90 hover:shadow-md active:bg-white/95 focus:outline-none focus-visible:ring-2 focus-visible:ring-white/40 transition">
          Get ONX PRO
        </button>
      </div>
    </article>
  </div> <!-- ✅ close grid -->
</section>

<!-- ===== Local styles for sheen/hover polish (scoped by #oc-Models) ===== -->
<style>
  #oc-Models .tilt { transition: transform .25s ease, box-shadow .25s ease; }
  @media (hover:hover){
    #oc-Models .tilt:hover { transform: translateY(-2px) scale(1.01); }
  }

  /* ---------- Apple-grade sheen for the dark (Pro) card ---------- */
  /* Structure: the card gets a super-soft ambient pass via ::before, and a brighter,
     thinner specular streak via ::after that accelerates + brightens on hover. */

  #oc-Models .pro-card {
    position: relative;
    background-image:
      linear-gradient(180deg, rgba(255,255,255,0.04), rgba(255,255,255,0) 18%),
      linear-gradient(0deg, rgba(255,255,255,0.03), rgba(255,255,255,0) 60%),
      radial-gradient(120% 160% at 100% -20%, rgba(255,255,255,0.06), transparent 50%);
    /* subtle inner glow near the top-right to emulate polished finish */
  }

  #oc-Models .sheen {
    isolation: isolate;
    overflow: hidden;            /* clip sheen to rounded corners */
    --sheen-angle: 120deg;       /* diagonal direction of the pass */
    --sheen-w: 26%;              /* width of the bright streak */
    --sheen-soft: 44%;           /* feathered edges */
    --ambient-alpha: .055;       /* ambient softness level */
    --streak-alpha: .18;         /* specular streak brightness (idle) */
    --streak-speed: 7.5s;        /* idle speed */
  }

  /* Ambient glassy veil (very soft, continuous) */
  #oc-Models .sheen::before {
    content: "";
    position: absolute;
    inset: -12%;
    border-radius: inherit;
    background:
      linear-gradient(var(--sheen-angle),
        rgba(255,255,255,0) calc(50% - var(--sheen-soft)),
        rgba(255,255,255,var(--ambient-alpha)) 50%,
        rgba(255,255,255,0) calc(50% + var(--sheen-soft))
      );
    transform: translateX(-140%) skewX(-12deg);
    animation: ocSheenAmbient var(--streak-speed) linear infinite;
    pointer-events: none;
    z-index: 0;
  }

  /* Brighter specular streak (thin highlight) */
  #oc-Models .sheen::after {
    content: "";
    position: absolute;
    inset: -14%;
    border-radius: inherit;
    background:
      linear-gradient(var(--sheen-angle),
        rgba(255,255,255,0) calc(50% - var(--sheen-w)),
        rgba(255,255,255,var(--streak-alpha)) 50%,
        rgba(255,255,255,0) calc(50% + var(--sheen-w))
      );
    filter: blur(10px) saturate(110%);
    transform: translateX(-160%) skewX(-14deg);
    animation: ocSheenPass var(--streak-speed) cubic-bezier(.16,1,.3,1) infinite;
    pointer-events: none;
    z-index: 1; /* sits above ambient but below content */
  }

  /* Hover: speed up and brighten the specular streak */
  @media (hover:hover){
    #oc-Models .sheen:hover {
      --streak-speed: 2.1s;
      --streak-alpha: .28;
    }
  }

  /* Keyframes for the sheen motion */
  @keyframes ocSheenAmbient {
    from { transform: translateX(-140%) skewX(-12deg); }
    to   { transform: translateX(140%)  skewX(-12deg); }
  }
  @keyframes ocSheenPass {
    0%   { transform: translateX(-160%) skewX(-14deg); }
    48%  { transform: translateX(110%)  skewX(-14deg); }
    100% { transform: translateX(160%)  skewX(-14deg); }
  }

  /* Reduced motion: keep the polished look without motion */
  @media (prefers-reduced-motion: reduce){
    #oc-Models .sheen::before,
    #oc-Models .sheen::after {
      animation: none !important;
      opacity: .12; /* static soft sheen */
      transform: translateX(0) skewX(-12deg);
    }
  }

  /* Existing helpers */
  #oc-Models .grid-stretch > * { height: 100%; }
  #oc-Models .rows-equal { grid-auto-rows: 1fr; }
</style>

<!-- (Optional) Tiny helper to ensure reveal class is applied if your global observer is disabled -->
<script>
  (function(){
    try{
      const root = document.getElementById('oc-Models');
      if (!root) return;
      if (!('IntersectionObserver' in window)) {
        root.classList.add('in');
        root.querySelectorAll('.scroll-fade').forEach(el=>el.classList.add('in-view'));
      }
    }catch(_){}
  })();
</script>

<!-- ────────────────────────── Brand Strip Section───────────────────────────────────── -->
<section class="padTop oc-brand-strip mx-auto max-w-[1200px] px-6">
  <!-- Microcopy -->
  <p class="mb-6 text-center text-[11px] leading-none tracking-[.24em] uppercase
             text-neutral-600 dark:text-white/60">
    Built on the platforms you trust
  </p>

  <!-- Logos row -->
  <ul class="grid grid-cols-4 items-center justify-items-center gap-10 md:gap-12"
      aria-label="Technology foundations">
    <li>
      <img data-oc-brand="google" alt="Google"
           class="h-10 md:h-12 lg:h-14 w-auto object-contain
                  opacity-0 transition-opacity duration-500
                  filter grayscale contrast-125 brightness-95
                  hover:grayscale-0 hover:brightness-100"
      />
    </li>

    <li>
      <img data-oc-brand="grok" alt="Grok"
           class="h-10 md:h-12 lg:h-14 w-auto object-contain
                  opacity-0 transition-opacity duration-500
                  filter grayscale contrast-125 brightness-95
                  hover:grayscale-0 hover:brightness-100"
      />
    </li>

    <li>
      <img data-oc-brand="meta" alt="Meta"
           class="h-10 md:h-12 lg:h-14 w-auto object-contain
                  opacity-0 transition-opacity duration-500
                  filter grayscale contrast-125 brightness-95
                  hover:grayscale-0 hover:brightness-100"
      />
    </li>

    <li>
      <img data-oc-brand="openai" alt="OpenAI"
           class="h-10 md:h-12 lg:h-14 w-auto object-contain
                  opacity-0 transition-opacity duration-500
                  filter grayscale contrast-125 brightness-95
                  hover:grayscale-0 hover:brightness-100"
      />
    </li>

  </ul>
</section>

<!-- Optional tiny loader (auto-wires [data-oc-brand] if no src is set) -->
<script>
(() => {
  const srcMap = {
    google: '/assets/brands/google.svg',
    openai: '/assets/brands/openai.svg',
    meta: '/assets/brands/meta.svg',
    grok: '/assets/brands/grok.svg'
  };

  document.querySelectorAll('img[data-oc-brand]').forEach(img => {
    const key = (img.getAttribute('data-oc-brand') || '').toLowerCase();
    const ensureFadeIn = () => requestAnimationFrame(() => img.style.opacity = '0.9');

    // Set src if missing
    if (!img.getAttribute('src') && srcMap[key]) img.src = srcMap[key];

    // Fade in once loaded
    if (img.complete) ensureFadeIn();
    else img.addEventListener('load', ensureFadeIn, { once: true });
  });
})();
</script>

<!-- Centered animated logo 
  <div class="mx-auto my-0 md:my-0 flex items-center justify-center">
    <span class="logo-anim LargeAniLogo" aria-label="ONX" style="--logo-size: clamp(56px, 30vw, 500px);"></span>
  </div> -->

 <!-- ────────────────────────── Download CTA Section───────────────────────────────────── -->
  <section id="download" class="padTop section-clip mx-auto max-w-[1200px] oc-container reveal">
    <div class="scroll-fade g-grad grad-anim rounded-3xl overflow-hidden border border-oc-line">
      <div class="p-8 md:p-12 flex flex-col gap-6 md:flex-row md:items-center md:justify-between">
        <div>
          <h2 class="text-2xl md:text-3xl font-semibold text-white">Get ONX</h2>
          <p class="mt-2 text-white/80 max-w-xl">Limitless AI for everything.</p>
        </div>
        <div class="flex flex-wrap items-center gap-3">
          <a href="download.html" class="btn inline-flex items-center gap-2 rounded-xl bg-white text-oc-ink px-4 py-2 font-medium hover:bg-gray-100 focus:ring-2 focus:ring-white/50"><i class="ph ph-apple-logo"></i> Download for macOS</a>
          <a href="download.html" class="btn inline-flex items-center gap-2 rounded-xl border border-white/30 bg-white/10 text-white px-4 py-2 font-medium hover:bg-white/20 focus:ring-2 focus:ring-white/40"><i class="ph ph-windows-logo"></i> Download for Windows</a>
        </div>
      </div>
    </div>
  </section>

  

<!-- ────────────────────────── Footer Section───────────────────────────────────── -->
  <footer>
    <div class="padTop mx-auto max-w-[1200px] oc-container py-12 flex items-center flex-col gap-6 text-oc-ink/60 text-sm">
      <div class="text-center">
        <span class="font-semibold text-black">ONX</span> © <span id="yr"></span> ONX
      </div>
      <div class="flex items-center gap-4">
        <a class="hover:text-oc-ink" href="contact.html">Contact</a>
        <a class="hover:text-oc-ink" href="privacy.html">Privacy</a>
        <a class="hover:text-oc-ink" href="terms.html">Terms</a>
        <a class="hover:text-oc-ink" href="download.html">Download</a>
      </div>
    </div>
  </footer>

  
  <script>
   

    // ================================
    // BRAND LOGO PATHS (global, easy to swap)
    // ================================
    window.OC_BRANDS = Object.assign({
      openai: 'OAILogo.png',
      google: 'googleLogo.svg',
      meta:   'metaLogo.svg',
      grok:   'grokLogo.svg'
    }, window.OC_BRANDS || {});

    // ================================
    // HERO TYPE-IN GLOBALS
    // ================================
    window.OC_HERO = Object.assign({
      enabled: true,
      startOnView: true,
      waitForBlur: true,
      startDelayMs: 200,
      staggerMs: 50,
      streamSpeed: 1.0,
      titleCharMin: 60,
      titleCharMax: 60,
      // Title delete timing (for reverse-typing out the brand before logo swap)
      titleDeleteMin: 20,
      titleDeleteMax: 30,
      titleDwellMs: 500,
      // Slower for "Your Counsel.", normal for "For "
      line1CharMin: 44,
      line1CharMax: 50,
      line2CharMin: 18,
      line2CharMax: 22,
      // Fallbacks for other sections using generic line speeds
      lineCharMin: 18,
      lineCharMax: 22,
      buttonCharMin: 5,
      buttonCharMax: 10
    }, window.OC_HERO || {});

    // ================================
    // HERO LOGO GLOW (global toggle)
    // ================================
    window.OC_HERO_GLOW = Object.assign({
      enabled: !!window.OC_ENABLE_HERO_LOGO_GLOW, // single switch at top
      pulse: true,             // enable subtle breathing pulse
      pulseDur: '6s',          // pulse duration
      color1: 'rgba(0,207,255,.40)', // primary glow
      color2: 'rgba(14,111,92,.28)', // secondary glow
      opacity: 0.55,           // target opacity after reveal
      blurPx: 30,              // blur radius in px
      insetPct: 16             // how far glow extends beyond logo (% of size)
    }, window.OC_HERO_GLOW || {});

    // ================================
    // NEW: HERO ROTATING WORD CONFIG (easy knobs + caret controls + mobile split)
    // ================================
    window.OC_HERO_ROTATOR = Object.assign({
      /* Desktop single-line prefix */
      prefix: 'For ',

      /* Mobile split behavior */
      mobileSplit: true,          // ← set to false to keep single line on mobile
      mobileBreakpoint: 768,      // ← Tailwind md breakpoint

      /* Mobile line texts (used only when mobileSplit === true) */
      prefixLine1: 'Your AI.',  // static top line on mobile
      prefixLine2: 'For ',           // second-line static prefix before rotating word

      /*words: [
        'everything.',
        'entrepreneurs.',
        'students.',
        'inventors.',
        'lawyers.',
        'designers.',
        'business owners.'
      ],*/

      words: [
  'everything',
  'entrepreneurs',
  'research',
  'students',
  'product R&D',
  'business',
  'law',
  'inventors',
  'designers',
  'creators',
  'developers',
  'entrepreneurs',
  'innovation'
],



      dwellMs: 2000,          // wait after a word is fully typed
      typeMin: 50,            // typing speed range (ms/char)
      typeMax: 70,
      deleteMin: 20,          // backspace speed range (ms/char)
      deleteMax: 30,

      // Caret controls (CSS variables injected on the container)
      caretBlinkMs: 800,                 // slightly faster, smoother blink
      caretWidthPx: 2,                   // border width in px
      caretColor: 'rgba(255,255,255,.92)'// caret color
    }, window.OC_HERO_ROTATOR || {});

    // ================================
    // SECTION TYPE-IN GLOBALS
    // ================================
    window.OC_SLY = Object.assign({
      enabled: true,
      startOnView: true,
      startDelayMs: 0,
      staggerMs: 0,
      streamSpeed: 1.0,
      titleCharMin: 30,
      titleCharMax: 30,
      lineCharMin: 10,
      lineCharMax: 10
    }, window.OC_SLY || {});

    window.OC_TCT = Object.assign({
      enabled: true,
      startOnView: true,
      startDelayMs: 0,
      staggerMs: 0,
      streamSpeed: 1.0,
      titleCharMin: 30,
      titleCharMax: 30,
      lineCharMin: 10,
      lineCharMax: 10
    }, window.OC_TCT || {});

    

    // Year
    const yr = document.getElementById('yr');
    if (yr) yr.textContent = new Date().getFullYear();

    // Scroll reveal (one-shot)
    const io = new IntersectionObserver((entries)=>{
      for (const e of entries) {
        if (e.isIntersecting) { e.target.classList.add('in'); io.unobserve(e.target); }
      }
    },{threshold:.12});
    document.querySelectorAll('.reveal').forEach(el=>io.observe(el));

    // ===== MOBILE SLIDE-IN MENU =====
    const hamburgerBtn = document.getElementById('hamburgerBtn');
    const mobileMenu   = document.getElementById('mobileMenu');
    const closeMenuBtn = document.getElementById('closeMenuBtn');

    function openMenu() {
      if (window.matchMedia('(min-width: 768px)').matches) return;
      mobileMenu.style.display = 'block'; void mobileMenu.offsetWidth;
      mobileMenu.classList.add('active'); hamburgerBtn.classList.add('is-active');
      hamburgerBtn.setAttribute('aria-expanded', 'true'); mobileMenu.setAttribute('aria-hidden','false');
      document.body.classList.add('overflow-hidden');
    }
    function closeMenu() {
      mobileMenu.classList.remove('active'); hamburgerBtn.classList.remove('is-active');
      hamburgerBtn.setAttribute('aria-expanded', 'false'); mobileMenu.setAttribute('aria-hidden','true');
      document.body.classList.remove('overflow-hidden');
      setTimeout(()=>{ if(!mobileMenu.classList.contains('active')) mobileMenu.style.display = 'none'; }, 550);
    }

    hamburgerBtn?.addEventListener('click', ()=> mobileMenu.classList.contains('active') ? closeMenu() : openMenu());
    closeMenuBtn?.addEventListener('click', closeMenu);
    mobileMenu?.addEventListener('click', (e)=>{ if (e.target.classList.contains('menu-scrim')) closeMenu(); });

    const mq = window.matchMedia('(min-width: 768px)');
    function handleMQ(e){ if (e.matches) closeMenu(); }
    if (mq.addEventListener) mq.addEventListener('change', handleMQ); else mq.addListener(handleMQ);

    document.addEventListener('keydown', (e)=>{ if (e.key === 'Escape') closeMenu(); });

    window.addEventListener('load', () => {
      const pageBlur = document.getElementById('pageBlur');
      if (!pageBlur) return;
      pageBlur.classList.add('hide');
      document.dispatchEvent(new Event('oc:page-blur-fade'));
      setTimeout(() => pageBlur.remove(), 1300);
    });

    // ================================
    // BLUR-ON-SCROLL OBSERVER (ONE-SHOT, PERSISTS UNTIL REFRESH)
    // ================================
    const sbo = new IntersectionObserver((entries) => {
      for (const e of entries) {
        if (e.isIntersecting) {
          e.target.classList.add('in-view');
          sbo.unobserve(e.target);
        }
      }
    }, { threshold: 0.35, rootMargin: "-12% 0px -12% 0px" });
    document.querySelectorAll('.scroll-fade').forEach(el => sbo.observe(el));

    // ===== Helpers =====
  
    function rand(a,b){ return Math.floor(Math.random()*(b-a+1))+a; }

    // Typewriter for plain text into an element
    function typewriter(el, text, min=10, max=18){
      return new Promise((resolve)=>{
        let i = 0;
        el.textContent = '';
        const tn = document.createTextNode('');
        el.appendChild(tn);
        (function tick(){
          tn.textContent = text.slice(0, i++);
          if (i <= text.length) setTimeout(tick, sp(rand(min,max)));
          else resolve();
        })();
      });
    }

    // Stream HTML with structure preserved (safe DOM walk; types text nodes char-by-char)
    async function streamHTML(el, html, charMin=10, charMax=18){
      const container = document.createElement('div');
      container.innerHTML = html.trim();

      async function walk(srcNode, dstParent){
        const children = Array.from(srcNode.childNodes);
        for (const child of children){
          if (child.nodeType === Node.TEXT_NODE){
            const text = child.textContent || '';
            await new Promise(res=>{
              let i=0;
              const tn = document.createTextNode('');
              dstParent.appendChild(tn);
              (function tick(){
                tn.textContent = text.slice(0, i++);
                if (i <= text.length) setTimeout(tick, sp(rand(charMin,charMax)));
                else res();
              })();
            });
          } else if (child.nodeType === Node.ELEMENT_NODE){
            const clone = child.cloneNode(false);
            dstParent.appendChild(clone);
            await walk(child, clone);
          }
        }
      }
      el.innerHTML = '';
      await walk(container, el);
    }

    // ================================
    // HERO: Show logo immediately, then type refined single-line tagline
    // ================================
    (function heroTyping(){
      const cfg = window.OC_HERO || {};
      if (!cfg.enabled) return;

      const hero = document.getElementById('home');
      if (!hero) return;

      const titleEl = hero.querySelector('.hero-title');
      const sub1El  = hero.querySelector('.hero-sub1');
      const ctaTxt  = hero.querySelector('.hero-cta-text');
      const ctaBtn  = hero.querySelector('#heroCtaBtn');

      if (!titleEl || !ctaTxt || !ctaBtn) return;

      const prefersReduced = window.matchMedia('(prefers-reduced-motion: reduce)').matches;

      const bTxt  = ctaTxt.textContent || '';

      // Refined Apple-style tagline (single line)
      const TAG1_BEFORE = '';
      const TAG1_BOLD   = '';
      const TAG1_AFTER  = '  AI Without Limits';
      const TAGLINE_FULL = TAG1_BEFORE + TAG1_BOLD + TAG1_AFTER;
      // Mobile split lines as requested
      const MOBILE_LINE1 = '';
      const MOBILE_LINE2 = 'AI Without Limits';
      const isMobile = window.matchMedia('(max-width: 767px)').matches;

      // Prepare hero: replace title with a wrapper containing the logo (and optional glow)
      titleEl.innerHTML = '';
      const wrapSpan = document.createElement('span');
      wrapSpan.className = 'hero-logo-wrap';
      titleEl.appendChild(wrapSpan);

      // Optional glow behind the logo (Apple-like), controlled by OC_HERO_GLOW
      const glowCfg = window.OC_HERO_GLOW || {};
      if (glowCfg.enabled) {
        const glow = document.createElement('span');
        glow.className = 'hero-logo-glow' + (glowCfg.pulse ? ' glow-pulse' : '');
        glow.style.setProperty('--glow-c1', String(glowCfg.color1 || 'rgba(0,207,255,.40)'));
        glow.style.setProperty('--glow-c2', String(glowCfg.color2 || 'rgba(14,111,92,.28)'));
        glow.style.setProperty('--glow-opacity', String(glowCfg.opacity ?? 0.55));
        glow.style.setProperty('--glow-blur', ((glowCfg.blurPx ?? 30)|0) + 'px');
        glow.style.setProperty('--glow-pulse-dur', String(glowCfg.pulseDur || '6s'));
        const inset = Math.max(0, Math.min(40, (glowCfg.insetPct ?? 16))) + '%';
        glow.style.inset = `-${inset}`;
        wrapSpan.appendChild(glow);
      }

      const logoSpanNow = document.createElement('span');
      logoSpanNow.className = 'hero-logo-white';
      logoSpanNow.setAttribute('role','img');
      logoSpanNow.setAttribute('aria-label','ONX');
      wrapSpan.appendChild(logoSpanNow);

      if (prefersReduced) {
        // Reduced motion: static line(s), reveal CTA (no animation)
        if (sub1El) {
          if (isMobile) {
            sub1El.innerHTML = `
              <span class="hero-line1">${MOBILE_LINE1}</span>
              <span class="hero-line2">${MOBILE_LINE2}</span>`;
          } else {
            sub1El.innerHTML = `<span class="hero-line1">${TAGLINE_FULL}</span>`;
          }
        }
        ctaBtn.classList.add('cta-visible');
        document.dispatchEvent(new Event('oc:cta-text-done'));
        return;
      }

      // Prepare for typing
      if (sub1El) sub1El.textContent = '';
      ctaTxt.textContent = '';
      ctaBtn.classList.remove('cta-visible');

      // local speed helpers honoring OC_HERO.streamSpeed
      function spH(ms){
        const f = (typeof cfg.streamSpeed === 'number' && cfg.streamSpeed > 0) ? cfg.streamSpeed : 1.0;
        return ms * f;
      }
      function typeHero(el, text, min, max){
        return new Promise(resolve=>{
          let i=0;
          const tn = document.createTextNode('');
          el.textContent = '';
          el.appendChild(tn);
          (function tick(){
            tn.textContent = text.slice(0, ++i);
            if (i <= text.length) setTimeout(tick, spH(rand(min,max)));
            else resolve();
          })();
        });
      }
      const wait = (ms)=> new Promise(r=>setTimeout(r, ms));

      function afterTransition(el, fallbackMs = 900){
        return new Promise((resolve)=>{
          let done = false;
          const finish = ()=>{ if (done) return; done = true; resolve(); };
          const onEnd = (e)=>{ if (e.target === el) finish(); };
          el.addEventListener('transitionend', onEnd, { once: true });
          setTimeout(()=>{ el.removeEventListener('transitionend', onEnd); finish(); }, fallbackMs);
        });
      }
      async function run(){
        await wait(Math.max(0, cfg.startDelayMs|0));
        // Type the tagline: two-line on mobile, single shimmering line on desktop
        if (sub1El){
          const min = (cfg.line1CharMin ?? cfg.lineCharMin) | 0;
          const max = (cfg.line1CharMax ?? cfg.lineCharMax) | 0;
          if (isMobile) {
            sub1El.innerHTML = '<span class="hero-line1"><span class="seg-fullshine l1"></span></span>\
                                <span class="hero-line2"><span class="seg-fullshine l2"></span></span>';
            const l1 = sub1El.querySelector('.l1');
            const l2 = sub1El.querySelector('.l2');
            await typeHero(l1, MOBILE_LINE1, min, max);
            await typeHero(l2, MOBILE_LINE2, min, max);
          } else {
            sub1El.innerHTML = '<span class="hero-line1"><span class="seg-fullshine"></span></span>';
            const segFull = sub1El.querySelector('.seg-fullshine');
            await typeHero(segFull, TAGLINE_FULL, min, max);
          }
        }
        await wait(cfg.staggerMs|0);
        ctaBtn.classList.add('cta-visible');
        document.dispatchEvent(new Event('oc:cta-visible'));
        await afterTransition(ctaBtn, 900);
        await wait(60);
        document.dispatchEvent(new Event('oc:cta-text-start'));
        await typeHero(ctaTxt, bTxt, cfg.buttonCharMin|0, cfg.buttonCharMax|0);
        document.dispatchEvent(new Event('oc:cta-text-done'));
      }

      let started = false;
      let inView = !cfg.startOnView;
      let blurReady = !cfg.waitForBlur;

      function tryStart(){
        if (!started && inView && blurReady){
          started = true; run();
        }
      }

      if (cfg.startOnView){
        const ob = new IntersectionObserver((entries)=>{
          for (const e of entries){
            if (e.isIntersecting){
              inView = true; tryStart(); ob.disconnect();
            }
          }
        }, { threshold:.35 });
        ob.observe(hero);
      }

      if (cfg.waitForBlur){
        document.addEventListener('oc:page-blur-fade', () => { blurReady = true; tryStart(); }, { once:true });
      } else {
        blurReady = true; tryStart();
      }
    })();

    // ================================
    // Rotator moved to section below hero (#sly-4 .sly-sub)
    // ================================
    (function movedRotator(){
      const root = document.querySelector('#sly-4 .sly-sub');
      const rCfg = window.OC_HERO_ROTATOR || {};
      const cfg = window.OC_HERO || {};
      if (!root || !rCfg.words || !rCfg.words.length) return;

      const prefersReduced = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
      const prefix = rCfg.prefix || 'Your AI. For ';
      const words = rCfg.words.slice();

      function spH(ms){
        const f = (typeof cfg.streamSpeed === 'number' && cfg.streamSpeed > 0) ? cfg.streamSpeed : 1.0;
        return ms * f;
      }
      function wait(ms){ return new Promise(r=>setTimeout(r, ms)); }
      function rand(a,b){ return Math.floor(Math.random()*(b-a+1))+a; }
      function type(el, text, min, max){
        return new Promise(resolve=>{
          let i=0; el.textContent=''; const tn=document.createTextNode(''); el.appendChild(tn);
          (function tick(){ tn.textContent=text.slice(0, ++i); if(i<=text.length) setTimeout(tick, spH(rand(min,max))); else resolve(); })();
        });
      }
      function del(el, min, max){
        return new Promise(resolve=>{
          const step=()=>{ const t=el.textContent||''; if(!t.length){ resolve(); return; } el.textContent=t.slice(0,-1); setTimeout(step, spH(rand(min,max))); };
          step();
        });
      }

      // Build simple single-line structure
      root.innerHTML = '<span class="rot-prefix"></span><span class="hero-word"></span><span class="hero-caret" aria-hidden="true"></span>';
      // caret styling reuse
      root.style.setProperty('--caret-blink', (rCfg.caretBlinkMs||800) + 'ms');
      root.style.setProperty('--caret-w', (rCfg.caretWidthPx||2) + 'px');
      root.style.setProperty('--caret-color', rCfg.caretColor || 'rgba(0,0,0,.85)');

      const pEl = root.querySelector('.rot-prefix');
      const wEl = root.querySelector('.hero-word');

      async function run(){
        if (prefersReduced){
          root.textContent = prefix + words[0];
          return;
        }
        await type(pEl, prefix, cfg.lineCharMin|0 || 12, cfg.lineCharMax|0 || 18);
        await type(wEl, words[0], rCfg.typeMin|0 || 40, rCfg.typeMax|0 || 70);

        let i = 1 % words.length;
        (async function loop(){
          await wait(spH(rCfg.dwellMs|0 || 2000));
          await del(wEl, rCfg.deleteMin|0 || 20, rCfg.deleteMax|0 || 30);
          await type(wEl, words[i], rCfg.typeMin|0 || 40, rCfg.typeMax|0 || 70);
          i = (i + 1) % words.length;
          loop();
        })();
      }

      // Start when section comes into view
      const ob = new IntersectionObserver((entries)=>{
        for (const e of entries){ if (e.isIntersecting){ run(); ob.disconnect(); } }
      }, { threshold: .35 });
      ob.observe(document.getElementById('sly-4'));
    })();

    // ================================
    // SECTION TYPERS
    // ================================
    function makeSectionTyper(rootSel, titleSel, subSel, cfg){
      const root  = document.querySelector(rootSel);
      if (!root || !cfg?.enabled) return;

      const prefersReduced = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
      if (prefersReduced) return;

      const titleEl = root.querySelector(titleSel);
      const subEl   = root.querySelector(subSel);

      if (!titleEl && !subEl) return;

      const tText = titleEl ? (titleEl.textContent || '') : '';
      const sText = subEl   ? (subEl.textContent   || '') : '';

      if (titleEl) titleEl.textContent = '';
      if (subEl)   subEl.textContent   = '';

      function spLocal(ms){
        const f = (typeof cfg.streamSpeed === 'number' && cfg.streamSpeed > 0) ? cfg.streamSpeed : 1.0;
        return ms * f;
      }
      function typeLocal(el, text, min, max){
        return new Promise(resolve=>{
          let i=0;
          const tn = document.createTextNode('');
          el.appendChild(tn);
          (function tick(){
            tn.textContent = text.slice(0, ++i);
            if (i <= text.length) setTimeout(tick, spLocal(rand(min,max)));
            else resolve();
          })();
        });
      }
      const wait = (ms)=> new Promise(r=>setTimeout(r, ms));

      async function run(){
        await wait(Math.max(0, cfg.startDelayMs|0));
        if (titleEl) await typeLocal(titleEl, tText, cfg.titleCharMin|0, cfg.titleCharMax|0);
        if (subEl){ await wait(cfg.staggerMs|0); await typeLocal(subEl, sText, cfg.lineCharMin|0, cfg.lineCharMax|0); }
      }

      if (cfg.startOnView){
        let started = false;
        const ob = new IntersectionObserver((entries)=>{
          for (const e of entries){
            if (e.isIntersecting && !started){
              started = true;
              run();
              ob.disconnect();
            }
          }
        }, { threshold:.35 });
        ob.observe(root);
      } else {
        run();
      }
    }

    makeSectionTyper('#sly', '.sly-title', '.sly-sub', window.OC_SLY);
    makeSectionTyper('#sly-2', '.sly-title', '.sly-sub', window.OC_SLY);
    makeSectionTyper('#sly-3', '.sly-title', '.sly-sub', window.OC_SLY);
    // '#sly-4' now hosts the moved rotator; skip generic typer there
    makeSectionTyper('#tct', '.tct-title', '.tct-sub', window.OC_TCT);



    // ===== Apply BRAND logo paths to <img data-oc-brand> =====
    (function applyBrandLogos(){
      const map = window.OC_BRANDS || {};
      document.querySelectorAll('img[data-oc-brand]').forEach(img=>{
        const key = img.getAttribute('data-oc-brand');
        if (map[key]) img.src = map[key];
      });
    })();

    // ===== Set HERO CTA icon based on OS (Windows ⇄ macOS) =====
    (function setHeroCtaIcon(){
      const el = document.getElementById('heroCtaIcon');
      if (!el) return;
      const os = (window.OC_OS || '').toLowerCase();
      el.classList.remove('ph-download','ph-apple-logo','ph-windows-logo');
      if (os === 'windows'){
        el.classList.add('ph-windows-logo');
        el.setAttribute('title','Windows');
        el.setAttribute('aria-label','Windows');
      } else {
        el.classList.add('ph-apple-logo');
        el.setAttribute('title','macOS');
        el.setAttribute('aria-label','macOS');
      }
    })();

(() => {
  class OCDownArrow extends HTMLElement {
    static get observedAttributes() {
      return [
        'dir','size','thickness','alpha',
        'amp','bounce','breathe',
        'from','via','to'
      ];
    }
    constructor(){ super(); this.attachShadow({mode:'open'}); }
    connectedCallback(){ this.render(); }
    attributeChangedCallback(){ this.render(); }

    render(){
      const dir       = (this.getAttribute('dir') || 'down').toLowerCase();
      const size      = Math.max(8, parseInt(this.getAttribute('size') || '72', 10));
      const thickness = Math.max(1, parseFloat(this.getAttribute('thickness') || '7'));
      const alpha     = Math.min(1, Math.max(0, parseFloat(this.getAttribute('alpha') ?? '0.85')));
      const amp       = (this.getAttribute('amp') || '14%').trim();
      const bounceDur = (this.getAttribute('bounce') || '1.8s').trim();
      const breatheDur= (this.getAttribute('breathe') || '3.6s').trim();

      const from = this.getAttribute('from') || '#ffffff';
      const via  = this.getAttribute('via')  || from;
      const to   = this.getAttribute('to')   || from;

      const reduce = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
      const rotation = ({ right:0, down:90, left:180, up:-90 }[dir] ?? 90);
      const gid = 'grad_' + Math.random().toString(36).slice(2);

      const animateTag = reduce ? '' : `
        <animateTransform attributeName="gradientTransform"
                          type="translate"
                          from="0 -1" to="0 1"
                          dur="8s" repeatCount="indefinite" />`;

      this.shadowRoot.innerHTML = `
        <style>
          :host { display:inline-block; line-height:0; }
          .wrap {
            --amp: ${amp};
            opacity: ${alpha};
            will-change: transform, filter, opacity;
            ${reduce ? '' : `animation:
              oc-bounce ${bounceDur} ease-in-out infinite,
              oc-breathe ${breatheDur} ease-in-out infinite;`}
            backface-visibility: hidden; transform: translateZ(0);
          }

          @keyframes oc-bounce {
            0%, 100% { transform: translateY(0); }
            50%      { transform: translateY(var(--amp)); }
          }
          @keyframes oc-breathe {
            0%, 100% { filter: drop-shadow(0 2px 8px rgba(255,255,255,.22))
                             drop-shadow(0 10px 26px rgba(255,255,255,.15)); }
            50%      { filter: drop-shadow(0 6px 18px rgba(255,255,255,.40))
                             drop-shadow(0 16px 40px rgba(255,255,255,.22)); }
          }

          svg { width:${size}px; height:${size}px; overflow:visible; }
          .stroke {
            stroke: url(#${gid});
            stroke-width:${thickness};
            stroke-linecap: round;
            stroke-linejoin: round;
            fill: none;
          }
        </style>

        <div class="wrap" part="wrap" aria-hidden="true">
          <svg viewBox="0 0 64 64" role="img" aria-label="Down arrow" style="transform: rotate(${rotation}deg);">
            <defs>
              <linearGradient id="${gid}" x1="0" y1="0" x2="0" y2="1" gradientUnits="objectBoundingBox">
                <stop offset="0%"   stop-color="${from}" />
                <stop offset="50%"  stop-color="${via}" />
                <stop offset="100%" stop-color="${to}" />
                ${animateTag}
              </linearGradient>
            </defs>

            <path class="stroke" d="M12 32 H44" />
            <path class="stroke" d="M44 20 L56 32 L44 44" />
          </svg>
        </div>
      `;
    }
  }

  if (!customElements.get('oc-down-arrow')) {
    customElements.define('oc-down-arrow', OCDownArrow);
  }
})();
  </script>
</body>
</html>
